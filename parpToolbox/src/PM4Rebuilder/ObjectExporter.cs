using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using ParpToolbox.Formats.PM4;
using ParpToolbox.Services.PM4;

namespace PM4Rebuilder
{
    /// <summary>
    /// Exports individual <see cref="Pm4ObjectAssembler.BuildingObject"/> records to Wavefront OBJ.
    /// Relies on the parent <see cref="Pm4Scene"/> vertices already being transformed to OBJ-friendly space.
    /// </summary>
    internal static class ObjectExporter
    {
        public static void Export(Pm4ObjectAssembler.BuildingObject obj, Pm4Scene scene, string outputDir)
        {
            if (obj.Triangles.Count == 0) return;

            Directory.CreateDirectory(outputDir);
            string filePath = Path.Combine(outputDir, $"{obj.Name}.obj");

            // Collect used vertices
            var used = new HashSet<int>();
            foreach (var (a, b, c) in obj.Triangles)
            {
                used.Add(a - 1); // triangles are stored 1-based
                used.Add(b - 1);
                used.Add(c - 1);
            }

            var remap = new Dictionary<int, int>();
            var ordered = used.OrderBy(i => i).ToList();
            int newIndex = 1;
            foreach (var oldIdx in ordered)
            {
                remap[oldIdx] = newIndex++;
            }

            using var sw = new StreamWriter(filePath);
            sw.WriteLine($"# PM4Rebuilder OBJ â€“ {obj.Name}");
            sw.WriteLine($"# Triangles: {obj.Triangles.Count}, Vertices: {ordered.Count}");
            sw.WriteLine();

            // Write vertices
            foreach (var oldIdx in ordered)
            {
                Vector3 v;
                if (oldIdx < scene.Vertices.Count)
                {
                    v = scene.Vertices[oldIdx];
                }
                else
                {
                    int mscnIdx = oldIdx - scene.Vertices.Count;
                    if (mscnIdx >= 0 && mscnIdx < scene.MscnVertices.Count)
                        v = scene.MscnVertices[mscnIdx];
                    else
                        v = Vector3.Zero; // placeholder for unmatched index
                }
                sw.WriteLine($"v {v.X:F6} {v.Y:F6} {v.Z:F6}");
            }
            sw.WriteLine();
            sw.WriteLine($"g {obj.Name}");

            // Write faces using remapped indices
            foreach (var (a, b, c) in obj.Triangles)
            {
                sw.WriteLine($"f {remap[a - 1]} {remap[b - 1]} {remap[c - 1]}");
            }
        }

        /// <summary>
        /// Export all objects merged into a single OBJ file for easier inspection.
        /// </summary>
        public static void ExportMergedSingleOBJ(List<Pm4ObjectAssembler.BuildingObject> objects, Pm4Scene scene, string outputDir, string fileName = "merged_all_objects")
        {
            if (objects.Count == 0) return;

            Directory.CreateDirectory(outputDir);
            string filePath = Path.Combine(outputDir, $"{fileName}.obj");

            Console.WriteLine($"[MERGED OBJ] Exporting {objects.Count} objects to single OBJ: {fileName}.obj");

            // Collect all used vertices globally
            var allUsedVertices = new HashSet<int>();
            foreach (var obj in objects)
            {
                foreach (var (a, b, c) in obj.Triangles)
                {
                    allUsedVertices.Add(a - 1); // triangles are stored 1-based
                    allUsedVertices.Add(b - 1);
                    allUsedVertices.Add(c - 1);
                }
            }

            // Create global vertex remapping
            var sortedIndices = allUsedVertices.OrderBy(x => x).ToArray();
            var globalRemap = new Dictionary<int, int>();
            for (int i = 0; i < sortedIndices.Length; i++)
            {
                globalRemap[sortedIndices[i]] = i + 1; // OBJ uses 1-based indexing
            }

            using var sw = new StreamWriter(filePath);
            
            // Header
            sw.WriteLine($"# Merged PM4 Objects - {objects.Count} objects combined");
            sw.WriteLine($"# Generated by PM4Rebuilder - Comprehensive Export");
            sw.WriteLine($"# Total vertices: {sortedIndices.Length}");
            sw.WriteLine($"# Total triangles: {objects.Sum(o => o.Triangles.Count)}");
            sw.WriteLine();

            // Write all vertices once
            sw.WriteLine("# Vertices (MSVT + MSCN combined)");
            foreach (int index in sortedIndices)
            {
                Vector3 v;
                if (index < scene.Vertices.Count)
                {
                    // MSVT vertex
                    v = scene.Vertices[index];
                }
                else
                {
                    // MSCN vertex
                    int mscnOffset = index - scene.Vertices.Count;
                    if (mscnOffset >= 0 && mscnOffset < scene.MscnVertices.Count)
                        v = scene.MscnVertices[mscnOffset];
                    else
                        v = Vector3.Zero; // placeholder for unmatched index
                }
                sw.WriteLine($"v {v.X:F6} {v.Y:F6} {v.Z:F6}");
            }
            sw.WriteLine();

            // Write each object as a group with its faces
            int totalTrianglesWritten = 0;
            foreach (var obj in objects)
            {
                if (obj.Triangles.Count == 0) continue;

                sw.WriteLine($"# Object: {obj.Name} - {obj.Triangles.Count} triangles");
                sw.WriteLine($"g {obj.Name}");

                foreach (var (a, b, c) in obj.Triangles)
                {
                    if (globalRemap.ContainsKey(a - 1) && globalRemap.ContainsKey(b - 1) && globalRemap.ContainsKey(c - 1))
                    {
                        sw.WriteLine($"f {globalRemap[a - 1]} {globalRemap[b - 1]} {globalRemap[c - 1]}");
                        totalTrianglesWritten++;
                    }
                }
                sw.WriteLine();
            }

            sw.WriteLine($"# Export complete: {totalTrianglesWritten} triangles written");
            
            Console.WriteLine($"[MERGED OBJ] Export complete: {sortedIndices.Length} vertices, {totalTrianglesWritten} triangles");
        }
    }
}
