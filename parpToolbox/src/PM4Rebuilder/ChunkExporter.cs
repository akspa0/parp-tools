using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using ParpToolbox.Formats.PM4;

namespace PM4Rebuilder
{
    /// <summary>
    /// Writes basic Wavefront OBJ files that correspond directly to PM4 chunk data – no object grouping.
    /// Currently supports:
    ///   • MSVT + MSUR geometry (faces)
    ///   • MSCN vertices (points only)
    ///   • MSLK links (line segments)
    /// </summary>
    internal static class ChunkExporter
    {
        /// <summary>
        /// Exports per-chunk OBJ files to <paramref name="outputDir"/>. Scene vertices must already be in final coordinate space.
        /// </summary>
        public static void Export(Pm4Scene scene, string outputDir)
        {
            Directory.CreateDirectory(outputDir);
            WriteMsvtMsur(scene, Path.Combine(outputDir, "scene_MSVT.obj"));
            WriteMscn(scene, Path.Combine(outputDir, "scene_MSCN.obj"));
            WriteMslk(scene, Path.Combine(outputDir, "scene_MSLK.obj"));
        }

        private static void WriteMsvtMsur(Pm4Scene scene, string path)
        {
            if (scene.Vertices.Count == 0 || scene.Surfaces.Count == 0 || scene.Indices.Count == 0)
            {
                Console.WriteLine("[ChunkExporter] No MSVT/MSUR geometry to write (missing vertices, surfaces, or indices).");
                return;
            }

            using var sw = new StreamWriter(path);
            sw.WriteLine("# MSVT + MSUR geometry – generated by PM4Rebuilder");
            sw.WriteLine("g MSVT_MSUR");

            // Vertices (already transformed)
            foreach (Vector3 v in scene.Vertices)
            {
                sw.WriteLine(FormattableString.Invariant($"v {v.X:F6} {v.Y:F6} {v.Z:F6}"));
            }

            long faceCount = 0;
            foreach (var surf in scene.Surfaces)
            {
                int start = (int)surf.MsviFirstIndex;
                int count = surf.IndexCount;
                if (start < 0 || count <= 2) continue;
                int max = Math.Min(start + count, scene.Indices.Count);

                // Assume triangles: groups of 3
                for (int i = start; i + 2 < max; i += 3)
                {
                    int ia = scene.Indices[i];
                    int ib = scene.Indices[i + 1];
                    int ic = scene.Indices[i + 2];
                    // Validate indices within vertices array (ignore MSCN for now)
                    if (ia < 0 || ia >= scene.Vertices.Count ||
                        ib < 0 || ib >= scene.Vertices.Count ||
                        ic < 0 || ic >= scene.Vertices.Count)
                        continue;
                    sw.WriteLine($"f {ia + 1} {ib + 1} {ic + 1}");
                    faceCount++;
                }
            }

            Console.WriteLine($"[ChunkExporter] Wrote MSVT/MSUR geometry to {Path.GetFileName(path)} (V={scene.Vertices.Count:N0}, F={faceCount:N0})");
        }

        private static void WriteMscn(Pm4Scene scene, string path)
        {
            if (scene.MscnVertices.Count == 0)
            {
                Console.WriteLine("[ChunkExporter] No MSCN vertices to write.");
                return;
            }

            using var sw = new StreamWriter(path);
            sw.WriteLine("# MSCN vertices – point cloud");
            sw.WriteLine("g MSCN_points");

            foreach (Vector3 v in scene.MscnVertices)
            {
                sw.WriteLine(FormattableString.Invariant($"v {v.X:F6} {v.Y:F6} {v.Z:F6}"));
            }
            // Optionally write points indices (OBJ 'p') – not all viewers read these, but safe to include
            for (int i = 1; i <= scene.MscnVertices.Count; i++)
            {
                sw.WriteLine($"p {i}");
            }

            Console.WriteLine($"[ChunkExporter] Wrote MSCN vertices to {Path.GetFileName(path)} (V={scene.MscnVertices.Count:N0})");
        }

        private static void WriteMslk(Pm4Scene scene, string path)
        {
            // Current schema does not expose explicit vertex indices for MSLK links.
            // Until mapping is confirmed, export a placeholder group so downstream tools
            // can at least load something without breaking.
            if (scene.Links.Count == 0)
                return;

            using var sw = new StreamWriter(path);
            sw.WriteLine("# MSLK links – placeholder (vertex indices unresolved)");
            sw.WriteLine("g MSLK_links");
            Console.WriteLine("[ChunkExporter] Skipped MSLK line export (Start/End indices not present in layout).");
        }
    }
}
