using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;

namespace PM4FacesTool;

internal static class ObjWriter
{
    public static void Write(
        string path,
        IReadOnlyList<Vector3> vertices,
        IReadOnlyList<(int A, int B, int C)> triangles,
        bool legacyParity,
        bool projectLocal,
        bool forceFlipX = false)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(path)!);

        // Prepare transformed vertices
        var verts = new Vector3[vertices.Count];
        if (projectLocal && vertices.Count > 0)
        {
            var mean = ComputeMean(vertices);
            for (int i = 0; i < vertices.Count; i++)
            {
                verts[i] = vertices[i] - mean;
            }
        }
        else
        {
            for (int i = 0; i < vertices.Count; i++) verts[i] = vertices[i];
        }

        bool flip = legacyParity || forceFlipX;
        if (flip)
        {
            for (int i = 0; i < verts.Length; i++)
            {
                var v = verts[i];
                // Mirror X to match legacy parity convention
                verts[i] = new Vector3(-v.X, v.Y, v.Z);
            }
        }

        using var sw = new StreamWriter(path);
        sw.WriteLine("# Generated by PM4FacesTool");
        sw.WriteLine("# vertices {0}", verts.Length);
        sw.WriteLine("# faces {0}", triangles.Count);

        string objName = Path.GetFileNameWithoutExtension(path);
        if (!string.IsNullOrWhiteSpace(objName))
        {
            sw.WriteLine("o {0}", SafeName(objName));
            sw.WriteLine("g {0}", SafeName(objName));
        }

        // Write vertices
        for (int i = 0; i < verts.Length; i++)
        {
            var v = verts[i];
            sw.Write("v ");
            sw.Write(v.X.ToString("G9", CultureInfo.InvariantCulture));
            sw.Write(' ');
            sw.Write(v.Y.ToString("G9", CultureInfo.InvariantCulture));
            sw.Write(' ');
            sw.Write(v.Z.ToString("G9", CultureInfo.InvariantCulture));
            sw.WriteLine();
        }

        // Write faces (1-based indexing)
        for (int i = 0; i < triangles.Count; i++)
        {
            var (a, b, c) = triangles[i];
            if (flip)
            {
                // Swap b/c after X-mirror to preserve normals
                (b, c) = (c, b);
            }

            // Defensive clamp to range; invalids are skipped
            if (!IsValidIndex(a, verts.Length) || !IsValidIndex(b, verts.Length) || !IsValidIndex(c, verts.Length))
                continue;

            sw.Write("f ");
            sw.Write((a + 1).ToString(CultureInfo.InvariantCulture));
            sw.Write(' ');
            sw.Write((b + 1).ToString(CultureInfo.InvariantCulture));
            sw.Write(' ');
            sw.Write((c + 1).ToString(CultureInfo.InvariantCulture));
            sw.WriteLine();
        }
    }

    private static Vector3 ComputeMean(IReadOnlyList<Vector3> vertices)
    {
        double sx = 0, sy = 0, sz = 0;
        for (int i = 0; i < vertices.Count; i++)
        {
            sx += vertices[i].X;
            sy += vertices[i].Y;
            sz += vertices[i].Z;
        }
        double inv = 1.0 / Math.Max(1, vertices.Count);
        return new Vector3((float)(sx * inv), (float)(sy * inv), (float)(sz * inv));
    }

    private static bool IsValidIndex(int i, int count) => i >= 0 && i < count;

    private static string SafeName(string name)
    {
        var invalid = Path.GetInvalidFileNameChars();
        var s = string.Join("_", name.Split(invalid, StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
        return string.IsNullOrWhiteSpace(s) ? "object" : s;
    }
}
