namespace ParpToolbox.Services.PM4;

using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using ParpToolbox.Formats.P4.Chunks.Common;
using ParpToolbox.Formats.PM4;

/// <summary>
/// Writes a comprehensive dump of a <see cref="Pm4Scene"/>: CSV plus OBJ exports for several grouping strategies.
/// Triggered by the CLI flag <c>--bulk-dump</c>.
/// </summary>
internal static class Pm4BulkDumper
{
    public static void Dump(Pm4Scene scene, string outputRoot, bool exportFaces)
    {
        Directory.CreateDirectory(outputRoot);
        // 1. Write CSV of raw MSUR fields.
        var csvPath = Path.Combine(outputRoot, "msur_dump.csv");
        using (var writer = new StreamWriter(csvPath))
        {
            writer.WriteLine("Idx,SurfaceKey,SurfaceGroupKey,Flags0x00,AttributeMask,MsviFirstIndex,IndexCount,IsM2Bucket");
            int idx = 0;
            foreach (var s in scene.Surfaces)
            {
                writer.WriteLine(string.Join(',',
                    idx++,
                    $"0x{s.SurfaceKey:X8}",
                    s.SurfaceGroupKey,
                    s.FlagsOrUnknown_0x00,
                    $"0x{s.SurfaceAttributeMask:X4}",
                    s.MsviFirstIndex,
                    s.IndexCount,
                    s.IsM2Bucket));
            }
        }

        // Helper to export groups
        void ExportGroups(Dictionary<uint, List<(int A, int B, int C)>> gmap, string subFolder)
        {
            var dir = Path.Combine(outputRoot, subFolder);
            Directory.CreateDirectory(dir);
            foreach (var (key, faces) in gmap)
            {
                if (faces.Count == 0) continue;
                var objPath = Path.Combine(dir, $"G{key:X8}.obj");
                WriteObj(objPath, scene.Vertices, faces, exportFaces);
            }
        }

        // 2a. Group by SurfaceKey (Unknown_0x1C)
        ExportGroups(BuildFaceGroups(scene, s => s.SurfaceKey), "by_surfacekey");

        // 2b. For surfaces with key==0, further group by (SurfaceGroupKey<<8)|Flags0x00
        ExportGroups(BuildFaceGroups(scene, s => s.SurfaceKey == 0 ? (uint)((s.SurfaceGroupKey << 8) | s.FlagsOrUnknown_0x00) : 0xFFFFFFFFu, filterKey: 0xFFFFFFFFu), "by_ground_subbucket");
    }

    private static Dictionary<uint, List<(int A, int B, int C)>> BuildFaceGroups(Pm4Scene scene, Func<MsurChunk.Entry, uint> keySelector, uint? filterKey = null)
    {
        var groups = new Dictionary<uint, List<(int,int,int)>>();
        var msviIndices = CollectMsviIndices(scene);
        foreach (var surf in scene.Surfaces)
        {
            if (surf.IsM2Bucket) continue; // skip overlay model bucket
            if (filterKey.HasValue && keySelector(surf) == filterKey.Value) continue;

            uint key = keySelector(surf);
            if (!groups.TryGetValue(key, out var faces))
            {
                faces = new();
                groups[key] = faces;
            }
            int first = (int)surf.MsviFirstIndex;
            int count = surf.IndexCount;
            if (first < 0 || count < 3 || first + count > msviIndices.Count) continue;
            for (int i = 0; i < count; i += 3)
            {
                faces.Add((msviIndices[first + i], msviIndices[first + i + 1], msviIndices[first + i + 2]));
            }
        }
        return groups;
    }

    private static List<int> CollectMsviIndices(Pm4Scene scene)
    {
        // The adapter already triangulated msvi -> scene.Triangles when present
        // But we also need raw index list for face remap. We can flatten.
        var list = new List<int>();
        foreach (var tri in scene.Triangles)
        {
            list.Add(tri.A);
            list.Add(tri.B);
            list.Add(tri.C);
        }
        return list;
    }

    private static void WriteObj(string path, IReadOnlyList<Vector3> verts, List<(int A, int B, int C)> faces, bool includeFaces)
    {
        using var sw = new StreamWriter(path);
        sw.WriteLine($"# Auto-generated by parpToolbox bulk-dump");
        foreach (var v in verts)
            sw.WriteLine(FormattableString.Invariant($"v {v.X:F6} {v.Y:F6} {v.Z:F6}"));
        if (includeFaces)
        {
            foreach (var (A,B,C) in faces)
                sw.WriteLine($"f {A+1} {B+1} {C+1}");
        }
    }
}
