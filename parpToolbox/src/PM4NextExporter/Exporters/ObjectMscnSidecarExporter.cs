using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using PM4NextExporter.Model;
using PM4NextExporter.Services;

namespace PM4NextExporter.Exporters
{
    internal static class ObjectMscnSidecarExporter
    {
        public static void Export(Scene scene,
                                  IEnumerable<AssembledObject> objects,
                                  Dictionary<AssembledObject, HashSet<int>> attribution,
                                  string outDir,
                                  bool legacyParity,
                                  bool nameWithTile,
                                  bool alignWithMscn)
        {
            if (scene == null || objects == null || attribution == null) return;
            Directory.CreateDirectory(outDir);
            var dir = Path.Combine(outDir, "objects-mscn");
            Directory.CreateDirectory(dir);

            var verts = scene.MscnVertices ?? new List<System.Numerics.Vector3>();
            if (verts.Count == 0) return;
            var tileIds = scene.MscnTileIds ?? new List<int>();
            bool hasTileIds = tileIds.Count == verts.Count && tileIds.Count > 0;

            var mirrorX = TransformConfig.ShouldMirrorX(ExporterKind.ObjectMscnSidecar, legacyParity, alignWithMscn);
            var ci = CultureInfo.InvariantCulture;

            foreach (var obj in objects)
            {
                if (!attribution.TryGetValue(obj, out var set) || set == null || set.Count == 0)
                    continue; // nothing to emit

                var name = string.IsNullOrWhiteSpace(obj.Name) ? "object" : obj.Name;
                var safeName = SanitizeFileName(name);
                var objPath = Path.Combine(dir, safeName + ".mscn.obj");
                var csvPath = Path.Combine(dir, safeName + ".mscn.csv");

                // OBJ points
                using (var sw = new StreamWriter(objPath))
                {
                    sw.WriteLine("# MSCN points sidecar - generated by PM4NextExporter");
                    sw.WriteLine($"o {name}.mscn");
                    var ordered = set.OrderBy(i => i).ToList();
                    foreach (var idx in ordered)
                    {
                        if (idx < 0 || idx >= verts.Count) continue;
                        var v = verts[idx];
                        var vx = mirrorX ? -v.X : v.X;
                        sw.WriteLine("v " + vx.ToString(ci) + " " + v.Y.ToString(ci) + " " + v.Z.ToString(ci));
                    }
                    for (int i = 0; i < ordered.Count; i++)
                        sw.WriteLine($"p {i + 1}");
                }

                // CSV diagnostics (optional per plan, but valuable by default when attribution exists)
                using (var sw = new StreamWriter(csvPath))
                {
                    sw.WriteLine("mscnIndex,x,y,z,tileId,tileX,tileY");
                    foreach (var idx in set.OrderBy(i => i))
                    {
                        if (idx < 0 || idx >= verts.Count) continue;
                        var v = verts[idx];
                        int tid = -1, tx = -1, ty = -1;
                        if (hasTileIds)
                        {
                            tid = tileIds[idx];
                            tx = tid % 64; ty = tid / 64;
                        }
                        sw.WriteLine(string.Join(',',
                            idx,
                            v.X.ToString(ci),
                            v.Y.ToString(ci),
                            v.Z.ToString(ci),
                            tid,
                            tx,
                            ty));
                    }
                }
            }
        }

        private static string SanitizeFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var s = string.Join("_", name.Split(invalid, StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
            return string.IsNullOrWhiteSpace(s) ? "object" : s;
        }
    }
}
