using System.Collections.Generic;
using System.IO;
using System.Linq;
using System;
using System.Globalization;
using PM4NextExporter.Model;

namespace PM4NextExporter.Exporters
{
    public static class ObjExporter
    {
        public static void Export(IEnumerable<AssembledObject> objects, string outDir, bool legacyParity = false)
        {
            // Back-compat wrapper
            Export(objects, outDir, legacyParity, projectLocal: false);
        }

        public static void Export(IEnumerable<AssembledObject> objects, string outDir, bool legacyParity, bool projectLocal)
        {
            Directory.CreateDirectory(outDir);
            var objectsDir = Path.Combine(outDir, "objects");
            Directory.CreateDirectory(objectsDir);

            var invertX = !legacyParity; // default: invert X unless legacy parity requested
            var ci = CultureInfo.InvariantCulture;

            var summaryLines = new List<string> {
                "name,vertices,triangles_written,triangles_skipped,filepath"
            };

            foreach (var obj in objects ?? Enumerable.Empty<AssembledObject>())
            {
                var name = string.IsNullOrWhiteSpace(obj.Name) ? "object" : obj.Name;
                var safeName = SanitizeFileName(name);
                var objPath = Path.Combine(objectsDir, safeName + ".obj");

                var verts = obj.Vertices ?? new List<System.Numerics.Vector3>();
                var tris = obj.Triangles ?? new List<(int A, int B, int C)>();

                int skipped = 0;
                int written = 0;

                using (var sw = new StreamWriter(objPath))
                {
                    sw.WriteLine("# generated by PM4NextExporter");
                    sw.WriteLine($"o {name}");

                    // vertices
                    System.Numerics.Vector3 origin = default;
                    if (projectLocal && verts.Count > 0)
                    {
                        double sx = 0, sy = 0, sz = 0;
                        for (int i = 0; i < verts.Count; i++)
                        {
                            var v0 = verts[i];
                            sx += v0.X; sy += v0.Y; sz += v0.Z;
                        }
                        origin = new System.Numerics.Vector3((float)(sx / verts.Count), (float)(sy / verts.Count), (float)(sz / verts.Count));
                    }
                    for (int i = 0; i < verts.Count; i++)
                    {
                        var v = verts[i];
                        var vx = v.X - origin.X;
                        var vy = v.Y - origin.Y;
                        var vz = v.Z - origin.Z;
                        var x = invertX ? -vx : vx;
                        sw.WriteLine("v " + x.ToString(ci) + " " + vy.ToString(ci) + " " + vz.ToString(ci));
                    }

                    // faces (1-based)
                    for (int i = 0; i < tris.Count; i++)
                    {
                        var (a, b, c) = tris[i];
                        if (a < 0 || b < 0 || c < 0 || a >= verts.Count || b >= verts.Count || c >= verts.Count)
                        {
                            skipped++;
                            continue;
                        }
                        // Preserve face orientation when mirroring X by swapping winding
                        if (invertX)
                        {
                            sw.WriteLine($"f {a + 1} {c + 1} {b + 1}");
                        }
                        else
                        {
                            sw.WriteLine($"f {a + 1} {b + 1} {c + 1}");
                        }
                        written++;
                    }
                }

                summaryLines.Add($"{EscapeCsv(name)},{verts.Count},{written},{skipped},{EscapeCsv(Path.GetRelativePath(outDir, objPath))}");
            }

            // Write summary CSV
            File.WriteAllLines(Path.Combine(outDir, "export_summary.csv"), summaryLines);
        }

        private static string SanitizeFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var s = string.Join("_", name.Split(invalid, StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
            return string.IsNullOrWhiteSpace(s) ? "object" : s;
        }

        private static string EscapeCsv(string s)
        {
            if (s.Contains(',') || s.Contains('"') || s.Contains('\n'))
            {
                return '"' + s.Replace("\"", "\"\"") + '"';
            }
            return s;
        }
    }
}
