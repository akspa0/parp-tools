using System.Collections.Generic;
using System.IO;
using System.Linq;
using System;
using System.Globalization;
using PM4NextExporter.Model;

namespace PM4NextExporter.Exporters
{
    public static class ObjExporter
    {
        public static void Export(IEnumerable<AssembledObject> objects, string outDir, bool legacyParity = false)
        {
            Directory.CreateDirectory(outDir);
            var objectsDir = Path.Combine(outDir, "objects");
            Directory.CreateDirectory(objectsDir);

            var invertX = !legacyParity; // default: invert X unless legacy parity requested
            var ci = CultureInfo.InvariantCulture;

            var summaryLines = new List<string> {
                "name,vertices,triangles_written,triangles_skipped,filepath"
            };

            foreach (var obj in objects ?? Enumerable.Empty<AssembledObject>())
            {
                var name = string.IsNullOrWhiteSpace(obj.Name) ? "object" : obj.Name;
                var safeName = SanitizeFileName(name);
                var objPath = Path.Combine(objectsDir, safeName + ".obj");

                var verts = obj.Vertices ?? new List<System.Numerics.Vector3>();
                var tris = obj.Triangles ?? new List<(int A, int B, int C)>();

                int skipped = 0;
                int written = 0;

                using (var sw = new StreamWriter(objPath))
                {
                    sw.WriteLine("# generated by PM4NextExporter");
                    sw.WriteLine($"o {name}");

                    // vertices
                    for (int i = 0; i < verts.Count; i++)
                    {
                        var v = verts[i];
                        var x = invertX ? -v.X : v.X;
                        sw.WriteLine("v " + x.ToString(ci) + " " + v.Y.ToString(ci) + " " + v.Z.ToString(ci));
                    }

                    // faces (1-based)
                    for (int i = 0; i < tris.Count; i++)
                    {
                        var (a, b, c) = tris[i];
                        if (a < 0 || b < 0 || c < 0 || a >= verts.Count || b >= verts.Count || c >= verts.Count)
                        {
                            skipped++;
                            continue;
                        }
                        sw.WriteLine($"f {a + 1} {b + 1} {c + 1}");
                        written++;
                    }
                }

                summaryLines.Add($"{EscapeCsv(name)},{verts.Count},{written},{skipped},{EscapeCsv(Path.GetRelativePath(outDir, objPath))}");
            }

            // Write summary CSV
            File.WriteAllLines(Path.Combine(outDir, "export_summary.csv"), summaryLines);
        }

        private static string SanitizeFileName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var s = string.Join("_", name.Split(invalid, StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
            return string.IsNullOrWhiteSpace(s) ? "object" : s;
        }

        private static string EscapeCsv(string s)
        {
            if (s.Contains(',') || s.Contains('"') || s.Contains('\n'))
            {
                return '"' + s.Replace("\"", "\"\"") + '"';
            }
            return s;
        }
    }
}
