using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using PM4NextExporter.Model;

namespace PM4NextExporter.Exporters
{
    internal static class MscnObjExporter
    {
        public static void Export(Scene scene, string outDir, bool legacyParity, bool nameWithTile)
        {
            if (scene == null) return;
            var verts = scene.MscnVertices ?? new List<System.Numerics.Vector3>();
            if (verts.Count == 0) return;

            var invertX = !legacyParity; // default: flip X; disable only with legacy parity
            var ci = CultureInfo.InvariantCulture;

            var mscnDir = Path.Combine(outDir, "mscn");
            Directory.CreateDirectory(mscnDir);

            var tileIds = scene.MscnTileIds ?? new List<int>();
            bool canSplitByTile = tileIds.Count == verts.Count && tileIds.Count > 0;

            if (!canSplitByTile)
            {
                // Single OBJ with all MSCN vertices
                var objPath = Path.Combine(mscnDir, "mscn.obj");
                using var sw = new StreamWriter(objPath);
                sw.WriteLine("# MSCN vertices - generated by PM4NextExporter");
                sw.WriteLine("o mscn");
                for (int i = 0; i < verts.Count; i++)
                {
                    var v = verts[i];
                    var vx = invertX ? -v.X : v.X;
                    sw.WriteLine("v " + vx.ToString(ci) + " " + v.Y.ToString(ci) + " " + v.Z.ToString(ci));
                }
                // emit points so viewers render vertices
                for (int i = 0; i < verts.Count; i++)
                    sw.WriteLine($"p {i + 1}");
                return;
            }

            // Group by tile id and export one OBJ per tile
            var groups = new Dictionary<int, List<int>>();
            for (int i = 0; i < tileIds.Count; i++)
            {
                int tid = tileIds[i];
                if (!groups.TryGetValue(tid, out var lst)) { lst = new List<int>(); groups[tid] = lst; }
                lst.Add(i);
            }

            foreach (var kvp in groups.OrderBy(k => k.Key))
            {
                var tid = kvp.Key;
                var indices = kvp.Value;
                var tileX = tid % 64;
                var tileY = tid / 64;
                var name = nameWithTile ? $"mscn_X{tileX:00}_Y{tileY:00}" : $"mscn_T{tid}";
                var objPath = Path.Combine(mscnDir, name + ".obj");
                using var sw = new StreamWriter(objPath);
                sw.WriteLine("# MSCN vertices (per-tile) - generated by PM4NextExporter");
                sw.WriteLine($"o {name}");

                // write vertices for this tile and a simple local index map
                int localCount = 0;
                foreach (var gi in indices)
                {
                    var v = verts[gi];
                    var vx = invertX ? -v.X : v.X;
                    sw.WriteLine("v " + vx.ToString(ci) + " " + v.Y.ToString(ci) + " " + v.Z.ToString(ci));
                    localCount++;
                }
                for (int i = 0; i < localCount; i++)
                    sw.WriteLine($"p {i + 1}");
            }
        }
    }
}
