using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using PM4NextExporter.Model;
using PM4NextExporter.Services;

namespace PM4NextExporter.Exporters
{
    internal static class PerTileObjectsExporter
    {
        private const int TileGridSize = 64; // must match assembler/grid sizing

        public static void Export(IEnumerable<AssembledObject> objects, string outDir, bool legacyParity, bool projectLocal, bool alignWithMscn)
        {
            if (objects == null) return;
            Directory.CreateDirectory(outDir);
            var tilesDir = Path.Combine(outDir, "tiles");
            Directory.CreateDirectory(tilesDir);

            var ci = CultureInfo.InvariantCulture;
            // Default behavior was "always mirror"; preserve unless aligning with MSCN dictates otherwise
            var mirrorDefault = TransformConfig.ShouldMirrorX(ExporterKind.PerTileObjects, legacyParity, alignWithMscn);

            // Group assembled objects by explicit tileX/tileY where available; fallback to tileId
            var groups = new Dictionary<(int X, int Y), List<AssembledObject>>();
            foreach (var obj in objects)
            {
                if (obj?.Meta == null) continue;
                if (TryGetTileXY(obj.Meta, out var tx, out var ty))
                {
                    var key = (tx, ty);
                    if (!groups.TryGetValue(key, out var list))
                    {
                        list = new List<AssembledObject>();
                        groups[key] = list;
                    }
                    list.Add(obj);
                }
                // If tile metadata absent, skip to avoid mis-grouping
            }

            foreach (var kv in groups.OrderBy(k => k.Key.Y).ThenBy(k => k.Key.X))
            {
                var (tileX, tileY) = kv.Key;
                var objs = kv.Value;

                var fileSafeName = $"tile_{tileX:D2}_{tileY:D2}";
                var objPath = Path.Combine(tilesDir, fileSafeName + ".obj");

                // For per-tile OBJ, preserve original global coordinates; ignore projectLocal
                System.Numerics.Vector3 origin = default;

                using var sw = new StreamWriter(objPath);
                sw.WriteLine("# generated by PM4NextExporter (per-tile assembled)");
                sw.WriteLine($"o {fileSafeName}");

                int vOffset = 0; // running vertex offset for faces (OBJ is 1-based; we add +1 at write time)

                foreach (var o in objs)
                {
                    var name = string.IsNullOrWhiteSpace(o.Name) ? "object" : o.Name;
                    sw.WriteLine($"o {name}");

                    var verts = o.Vertices ?? new List<System.Numerics.Vector3>();
                    var tris = o.Triangles ?? new List<(int A, int B, int C)>();

                    // Determine center for aligned mirroring (per object)
                    float centerRelX = 0f;
                    if (alignWithMscn && mirrorDefault && verts.Count > 0)
                    {
                        double sx = 0;
                        for (int i = 0; i < verts.Count; i++) sx += verts[i].X;
                        var centerX = (float)(sx / verts.Count);
                        centerRelX = centerX - origin.X;
                    }

                    // write vertices for this object (global coordinates)
                    for (int i = 0; i < verts.Count; i++)
                    {
                        var v = verts[i];
                        var vx = v.X - origin.X;
                        var vy = v.Y - origin.Y;
                        var vz = v.Z - origin.Z;
                        float x;
                        if (alignWithMscn)
                        {
                            x = TransformConfig.MirrorX(vx, centerRelX, mirrorDefault);
                        }
                        else
                        {
                            x = mirrorDefault ? -vx : vx;
                        }
                        sw.WriteLine("v " + x.ToString("G9", ci) + " " + vy.ToString("G9", ci) + " " + vz.ToString("G9", ci));
                    }

                    // write faces for this object (indices are local to this object's vertex list)
                    for (int i = 0; i < tris.Count; i++)
                    {
                        var (a, b, c) = tris[i];
                        if (a < 0 || b < 0 || c < 0 || a >= verts.Count || b >= verts.Count || c >= verts.Count)
                        {
                            continue; // skip malformed
                        }
                        if (mirrorDefault)
                        {
                            sw.WriteLine($"f {vOffset + a + 1} {vOffset + c + 1} {vOffset + b + 1}");
                        }
                        else
                        {
                            sw.WriteLine($"f {vOffset + a + 1} {vOffset + b + 1} {vOffset + c + 1}");
                        }
                    }

                    vOffset += verts.Count;
                }
            }
        }

        private static bool TryGetTileXY(Dictionary<string, string> meta, out int tileX, out int tileY)
        {
            tileX = 0; tileY = 0;
            if (meta == null) return false;
            // Prefer explicit X/Y
            bool okX = false, okY = false;
            if (meta.TryGetValue("tileX", out var sx)) okX = int.TryParse(sx, NumberStyles.Integer, CultureInfo.InvariantCulture, out tileX);
            if (meta.TryGetValue("tileY", out var sy)) okY = int.TryParse(sy, NumberStyles.Integer, CultureInfo.InvariantCulture, out tileY);
            if (okX && okY) return true;

            // Fallback: derive from tileId using known grid size
            if (meta.TryGetValue("tileId", out var s) && int.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out var tileId))
            {
                tileX = tileId % TileGridSize;
                tileY = tileId / TileGridSize;
                return true;
            }
            return false;
        }
    }
}
