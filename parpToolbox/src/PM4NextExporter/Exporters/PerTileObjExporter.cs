using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using PM4NextExporter.Model;

namespace PM4NextExporter.Exporters
{
    internal static class PerTileObjExporter
    {
        public static void Export(Scene scene, string outDir, bool legacyParity, bool projectLocal)
        {
            if (scene == null) return;
            var tilesDir = Path.Combine(outDir, "tiles");
            Directory.CreateDirectory(tilesDir);

            var ci = CultureInfo.InvariantCulture;
            var invertX = !legacyParity; // match ObjExporter behavior

            // Compute total render vertex count (pre-MSCN)
            int renderTotal = 0;
            if (scene.TileVertexCountByTileId?.Count > 0)
            {
                foreach (var kvp in scene.TileVertexCountByTileId)
                    renderTotal += kvp.Value;
            }
            else
            {
                // Fallback: if counts missing, assume MSCN block appended after render vertices
                // i.e., renderTotal = scene.Vertices.Count - scene.MscnVertices.Count
                renderTotal = Math.Max(0, (scene.Vertices?.Count ?? 0) - (scene.MscnVertices?.Count ?? 0));
            }

            // Materialize maps to avoid nullable warnings
            var vOffMap = scene.TileVertexOffsetByTileId ?? new Dictionary<int, int>();
            var iOffMap = scene.TileIndexOffsetByTileId ?? new Dictionary<int, int>();
            var vCntMap = scene.TileVertexCountByTileId ?? new Dictionary<int, int>();
            var iCntMap = scene.TileIndexCountByTileId ?? new Dictionary<int, int>();

            // Iterate tiles in deterministic order
            var tileIds = (vOffMap.Keys ?? Enumerable.Empty<int>())
                .OrderBy(id => id)
                .ToList();

            foreach (var tileId in tileIds)
            {
                var x = tileId % 64;
                var y = tileId / 64;
                var safeName = $"tile_{x:D2}_{y:D2}";
                var objPath = Path.Combine(tilesDir, safeName + ".obj");

                if (!vOffMap.TryGetValue(tileId, out var vStart)) vStart = 0;
                if (!vCntMap.TryGetValue(tileId, out var vCount)) vCount = 0;
                if (!iOffMap.TryGetValue(tileId, out var iStart)) iStart = 0;
                if (!iCntMap.TryGetValue(tileId, out var iCount)) iCount = 0;

                var vertices = scene.Vertices ?? new List<Vector3>();
                var indices = scene.Indices ?? new List<int>();
                var mscn = scene.MscnVertices ?? new List<Vector3>();

                // Map from global vertex index to local index for this tile OBJ
                var g2l = new Dictionary<int, int>(capacity: vCount + 256);
                var localVerts = new List<Vector3>(vCount + 256);

                // Seed local verts with render vertices for this tile
                for (int g = vStart; g < vStart + vCount && g < vertices.Count; g++)
                {
                    g2l[g] = localVerts.Count;
                    localVerts.Add(vertices[g]);
                }

                int triStart = iStart;
                int triEnd = Math.Min(indices.Count, iStart + iCount);
                var localTris = new List<(int A, int B, int C)>(((triEnd - triStart) / 3) + 8);

                for (int i = triStart; i + 2 < triEnd; i += 3)
                {
                    int ga = indices[i];
                    int gb = indices[i + 1];
                    int gc = indices[i + 2];

                    int la = -1, lb = -1, lc = -1;
                    bool oka = TryMap(scene, renderTotal, ga, vStart, vCount, mscn, vertices, g2l, localVerts, out la);
                    bool okb = TryMap(scene, renderTotal, gb, vStart, vCount, mscn, vertices, g2l, localVerts, out lb);
                    bool okc = TryMap(scene, renderTotal, gc, vStart, vCount, mscn, vertices, g2l, localVerts, out lc);
                    if (!(oka && okb && okc)) continue; // skip malformed

                    localTris.Add((la, lb, lc));
                }

                using var sw = new StreamWriter(objPath);
                sw.WriteLine("# generated by PM4NextExporter (per-tile)");
                sw.WriteLine($"o {safeName}");

                // write vertices
                System.Numerics.Vector3 origin = default;
                if (projectLocal && localVerts.Count > 0)
                {
                    double sx = 0, sy = 0, sz = 0;
                    for (int i = 0; i < localVerts.Count; i++)
                    {
                        var v0 = localVerts[i];
                        sx += v0.X; sy += v0.Y; sz += v0.Z;
                    }
                    origin = new System.Numerics.Vector3(
                        (float)(sx / localVerts.Count),
                        (float)(sy / localVerts.Count),
                        (float)(sz / localVerts.Count));
                }
                for (int i = 0; i < localVerts.Count; i++)
                {
                    var v = localVerts[i];
                    var vx = v.X - origin.X;
                    var vy = v.Y - origin.Y;
                    var vz = v.Z - origin.Z;
                    var xmir = invertX ? -vx : vx;
                    sw.WriteLine("v " + xmir.ToString(ci) + " " + vy.ToString(ci) + " " + vz.ToString(ci));
                }

                // write faces with winding compensation if mirrored
                for (int i = 0; i < localTris.Count; i++)
                {
                    var (a, b, c) = localTris[i];
                    if (invertX)
                        sw.WriteLine($"f {a + 1} {c + 1} {b + 1}");
                    else
                        sw.WriteLine($"f {a + 1} {b + 1} {c + 1}");
                }
            }
        }

        private static bool TryMap(
            Scene scene,
            int renderTotal,
            int g,
            int vStart,
            int vCount,
            List<Vector3> mscn,
            List<Vector3> vertices,
            Dictionary<int, int> g2l,
            List<Vector3> localVerts,
            out int local)
        {
            local = -1;
            if (g < 0) return false;

            // In-range render vertex for this tile
            if (g >= vStart && g < vStart + vCount && g < vertices.Count)
            {
                if (!g2l.TryGetValue(g, out local))
                {
                    local = localVerts.Count;
                    g2l[g] = local;
                    localVerts.Add(vertices[g]);
                }
                return true;
            }

            // MSCN reference (after render vertices)
            if (g >= renderTotal)
            {
                int mOff = g - renderTotal;
                if (mOff < 0 || mOff >= mscn.Count) return false;
                int key = renderTotal + mOff; // stable key per global index
                if (!g2l.TryGetValue(key, out local))
                {
                    local = localVerts.Count;
                    g2l[key] = local;
                    localVerts.Add(mscn[mOff]);
                }
                return true;
            }

            // Cross-tile render reference: copy-once into this tile OBJ
            if (g < vertices.Count)
            {
                if (!g2l.TryGetValue(g, out local))
                {
                    local = localVerts.Count;
                    g2l[g] = local;
                    localVerts.Add(vertices[g]);
                }
                return true;
            }

            return false;
        }
    }
}
