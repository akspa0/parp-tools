# WoWRollback Analysis Module Implementation Plan

**Created**: 2025-10-07  
**Purpose**: Implement missing analysis and overlay generation functionality

---

## üéØ Problem Statement

The orchestrator successfully converts ADTs and patches AreaIDs, but is **missing critical outputs**:

1. **UniqueID CSVs** - Required for Phase 0 time-travel visualization
2. **Per-tile overlay JSONs** - Required for viewer plugin system
3. **MCNK terrain CSVs** - Required for terrain metadata display
4. **Overlay manifest** - Required for plugin architecture coordination

These were previously generated by `AlphaWdtAnalyzer.Core` but are not wired into the unified orchestrator.

---

## üìê Architecture

### New Module: `WoWRollback.AnalysisModule`

```
WoWRollback/
‚îú‚îÄ WoWRollback.AnalysisModule/
‚îÇ  ‚îú‚îÄ AnalysisOrchestrator.cs         // Main API
‚îÇ  ‚îú‚îÄ UniqueIdAnalyzer.cs             // Phase 0: Time-travel CSVs
‚îÇ  ‚îú‚îÄ TerrainCsvGenerator.cs          // MCNK terrain data extraction
‚îÇ  ‚îú‚îÄ OverlayGenerator.cs             // Per-tile JSON generation
‚îÇ  ‚îú‚îÄ OverlayManifestBuilder.cs       // Plugin manifest creation
‚îÇ  ‚îî‚îÄ Models.cs                       // Result types
```

### Integration Point

```
PipelineOrchestrator.Run()
‚îú‚îÄ 1. DbcStageRunner       ‚úì Working
‚îú‚îÄ 2. AdtStageRunner       ‚úì Working
‚îú‚îÄ 3. AnalysisStageRunner  ‚Üê NEW (missing!)
‚îî‚îÄ 4. ViewerStageRunner    ‚úì Working
```

---

## üìã Required Outputs

### 1. UniqueID Analysis CSVs

**Location**: `04_analysis/{version}/uniqueids/`

**Files**:
- `{mapName}_uniqueID_analysis.csv` - Per-tile ID distributions
- `{mapName}_layers.json` - Detected work layers

**Format** (from `03_Rollback_TimeTravel_Feature.md`):
```csv
MapName,TileX,TileY,AssetType,MinId,MaxId,Count,Layer
Shadowfang,25,30,M2,1234,2456,45,1
Shadowfang,25,30,WMO,1000,1500,12,1
```

### 2. MCNK Terrain CSVs

**Location**: `04_analysis/{version}/terrain/`

**Files**:
- `{mapName}_mcnk_terrain.csv` - Complete MCNK data
- `{mapName}_mcnk_properties.csv` - Flags, layers, holes

**Contains**:
- Tile coordinates
- AreaID (patched LK values)
- Flags (has liquids, has holes, etc.)
- Texture layer counts
- Hole patterns

### 3. Per-Tile Overlay JSONs

**Location**: `05_viewer/overlays/{version}/{mapName}/`

**Structure** (from `04_Overlay_Plugin_Architecture.md`):
```
overlays/
‚îú‚îÄ 0.5.3/
‚îÇ  ‚îî‚îÄ Shadowfang/
‚îÇ     ‚îú‚îÄ terrain_complete/
‚îÇ     ‚îÇ  ‚îú‚îÄ tile_25_30.json
‚îÇ     ‚îÇ  ‚îú‚îÄ tile_25_31.json
‚îÇ     ‚îÇ  ‚îî‚îÄ ...
‚îÇ     ‚îú‚îÄ objects_combined/
‚îÇ     ‚îÇ  ‚îú‚îÄ tile_25_30.json  // M2 + WMO placements
‚îÇ     ‚îÇ  ‚îî‚îÄ ...
‚îÇ     ‚îî‚îÄ shadow_map/
‚îÇ        ‚îú‚îÄ tile_25_30.json  // Shadow metadata
‚îÇ        ‚îî‚îÄ ...
```

**Terrain Overlay Format**:
```json
{
  "tileX": 25,
  "tileY": 30,
  "areaId": 209,
  "properties": {
    "hasLiquids": true,
    "hasHoles": false,
    "layers": 3
  },
  "liquids": [
    {"type": "water", "level": 10.5, "coverage": 0.35}
  ]
}
```

**Objects Overlay Format**:
```json
{
  "tileX": 25,
  "tileY": 30,
  "m2Placements": [
    {
      "uniqueId": 1234,
      "fileId": "World/Generic/Human/Passive Doodads/Chest/Chest01.mdx",
      "position": [1234.5, 5678.9, 100.2],
      "rotation": [0, 0, 0],
      "scale": 1.0
    }
  ],
  "wmoplacements": [
    {
      "uniqueId": 5000,
      "fileId": "World/wmo/Azeroth/Buildings/HumanFarm/HumanFarm.wmo",
      "position": [2000.0, 3000.0, 50.0],
      "rotation": [0, 1.57, 0],
      "doodadSet": 0
    }
  ]
}
```

### 4. Overlay Manifest

**Location**: `05_viewer/overlay_manifest.json`

**Format** (from plugin architecture):
```json
{
  "version": "0.5.3",
  "map": "Shadowfang",
  "overlays": [
    {
      "id": "terrain.properties",
      "plugin": "terrain",
      "title": "Terrain Properties",
      "tiles": "complete",
      "resources": {
        "tilePattern": "overlays/{version}/{map}/terrain_complete/tile_{col}_{row}.json"
      }
    },
    {
      "id": "objects.combined",
      "plugin": "objects",
      "subtype": "combined",
      "tiles": "complete",
      "resources": {
        "tilePattern": "overlays/{version}/{map}/objects_combined/tile_{col}_{row}.json"
      }
    }
  ]
}
```

---

## üèóÔ∏è Implementation

### Phase 1: Create AnalysisModule Project

```bash
cd WoWRollback
dotnet new classlib -n WoWRollback.AnalysisModule -f net9.0
dotnet sln add WoWRollback.AnalysisModule
```

**Project References**:
- `WoWRollback.Core` (for LK ADT reading)
- `AlphaWdtAnalyzer.Core` (for existing terrain/shadow extractors)

### Phase 2: Implement AnalysisOrchestrator

```csharp
public sealed class AnalysisOrchestrator
{
    public AnalysisResult RunAnalysis(
        string adtOutputDir,
        string analysisOutputDir,
        string viewerOutputDir,
        string mapName,
        string version,
        AnalysisOptions opts)
    {
        // 1. Generate UniqueID CSVs
        var uniqueIdResult = GenerateUniqueIdAnalysis(adtOutputDir, analysisOutputDir, mapName);
        
        // 2. Extract MCNK terrain CSVs
        var terrainResult = GenerateTerrainCsvs(adtOutputDir, analysisOutputDir, mapName);
        
        // 3. Generate overlay JSONs
        var overlayResult = GenerateOverlays(adtOutputDir, viewerOutputDir, mapName, version);
        
        // 4. Build overlay manifest
        var manifestResult = BuildOverlayManifest(viewerOutputDir, mapName, version, overlayResult);
        
        return new AnalysisResult(
            UniqueIdCsvs: uniqueIdResult.CsvPaths,
            TerrainCsvs: terrainResult.CsvPaths,
            OverlayCount: overlayResult.TileCount,
            ManifestPath: manifestResult.ManifestPath,
            Success: true
        );
    }
}
```

### Phase 3: Implement Core Analyzers

#### UniqueIdAnalyzer
```csharp
public sealed class UniqueIdAnalyzer
{
    public UniqueIdAnalysisResult Analyze(string adtDir, string mapName)
    {
        var adtFiles = Directory.GetFiles(adtDir, "*.adt");
        var distributions = new List<TileIdDistribution>();
        
        foreach (var adtPath in adtFiles)
        {
            // Read LK ADT (MDDF + MODF chunks)
            var adt = LkAdtReader.Read(adtPath);
            
            // Extract uniqueIDs from M2 and WMO placements
            var m2Ids = adt.M2Placements.Select(p => p.UniqueId).OrderBy(id => id).ToList();
            var wmoIds = adt.WmoPlac.Select(p => p.UniqueId).OrderBy(id => id).ToList();
            
            // Detect layers (gaps > 100 IDs = new layer)
            var m2Layers = DetectLayers(m2Ids);
            var wmoLayers = DetectLayers(wmoIds);
            
            distributions.Add(new TileIdDistribution
            {
                TileX = adt.TileX,
                TileY = adt.TileY,
                M2Distribution = m2Layers,
                WmoDistribution = wmoLayers
            });
        }
        
        // Export CSV
        var csvPath = ExportCsv(distributions, mapName);
        
        return new UniqueIdAnalysisResult(csvPath, distributions.Count);
    }
}
```

#### TerrainCsvGenerator
```csharp
public sealed class TerrainCsvGenerator
{
    public TerrainCsvResult Generate(string adtDir, string outputDir, string mapName)
    {
        // Leverage existing AlphaWdtAnalyzer.Core extractors
        var extractor = new McnkTerrainExtractor();
        var records = new List<TerrainRecord>();
        
        foreach (var adtPath in Directory.GetFiles(adtDir, "*.adt"))
        {
            var adt = LkAdtReader.Read(adtPath);
            
            // Extract MCNK data
            foreach (var mcnk in adt.McnkChunks)
            {
                records.Add(new TerrainRecord
                {
                    TileX = adt.TileX,
                    TileY = adt.TileY,
                    ChunkX = mcnk.IndexX,
                    ChunkY = mcnk.IndexY,
                    AreaId = mcnk.AreaId,  // Patched LK value!
                    Flags = mcnk.Flags,
                    Layers = mcnk.TextureLayers.Count,
                    HasLiquids = mcnk.HasLiquids,
                    HasHoles = mcnk.HasHoles
                });
            }
        }
        
        var csvPath = Path.Combine(outputDir, $"{mapName}_mcnk_terrain.csv");
        ExportCsv(records, csvPath);
        
        return new TerrainCsvResult(csvPath, records.Count);
    }
}
```

#### OverlayGenerator
```csharp
public sealed class OverlayGenerator
{
    public OverlayGenerationResult Generate(
        string adtDir,
        string viewerDir,
        string mapName,
        string version)
    {
        var terrainOverlaysDir = Path.Combine(viewerDir, "overlays", version, mapName, "terrain_complete");
        var objectsOverlaysDir = Path.Combine(viewerDir, "overlays", version, mapName, "objects_combined");
        
        Directory.CreateDirectory(terrainOverlaysDir);
        Directory.CreateDirectory(objectsOverlaysDir);
        
        int tilesProcessed = 0;
        
        foreach (var adtPath in Directory.GetFiles(adtDir, "*.adt"))
        {
            var adt = LkAdtReader.Read(adtPath);
            
            // Generate terrain overlay JSON
            var terrainOverlay = new
            {
                tileX = adt.TileX,
                tileY = adt.TileY,
                areaId = adt.McnkChunks.First().AreaId,
                properties = new
                {
                    hasLiquids = adt.McnkChunks.Any(c => c.HasLiquids),
                    hasHoles = adt.McnkChunks.Any(c => c.HasHoles),
                    layers = adt.McnkChunks.Max(c => c.TextureLayers.Count)
                }
            };
            
            var terrainPath = Path.Combine(terrainOverlaysDir, $"tile_{adt.TileX}_{adt.TileY}.json");
            File.WriteAllText(terrainPath, JsonSerializer.Serialize(terrainOverlay, new JsonSerializerOptions { WriteIndented = true }));
            
            // Generate objects overlay JSON
            var objectsOverlay = new
            {
                tileX = adt.TileX,
                tileY = adt.TileY,
                m2Placements = adt.M2Placements.Select(p => new
                {
                    uniqueId = p.UniqueId,
                    fileId = p.MdxPath,
                    position = new[] { p.Position.X, p.Position.Y, p.Position.Z },
                    rotation = new[] { p.Rotation.X, p.Rotation.Y, p.Rotation.Z },
                    scale = p.Scale
                }),
                wmoplacements = adt.WmoPlac.Select(p => new
                {
                    uniqueId = p.UniqueId,
                    fileId = p.WmoPath,
                    position = new[] { p.Position.X, p.Position.Y, p.Position.Z },
                    rotation = new[] { p.Rotation.X, p.Rotation.Y, p.Rotation.Z },
                    doodadSet = p.DoodadSet
                })
            };
            
            var objectsPath = Path.Combine(objectsOverlaysDir, $"tile_{adt.TileX}_{adt.TileY}.json");
            File.WriteAllText(objectsPath, JsonSerializer.Serialize(objectsOverlay, new JsonSerializerOptions { WriteIndented = true }));
            
            tilesProcessed++;
        }
        
        return new OverlayGenerationResult(tilesProcessed, Success: true);
    }
}
```

### Phase 4: Create AnalysisStageRunner

```csharp
// WoWRollback.Orchestrator/AnalysisStageRunner.cs
internal sealed class AnalysisStageRunner
{
    public AnalysisStageResult Run(
        SessionContext session,
        IReadOnlyList<AdtStageResult> adtResults)
    {
        var results = new List<AnalysisResult>();
        var orchestrator = new AnalysisOrchestrator();
        
        foreach (var adtResult in adtResults.Where(r => r.Success))
        {
            var adtOutputDir = Path.Combine(session.Paths.AdtDir, adtResult.Version);
            var analysisOutputDir = Path.Combine(session.Paths.AnalysisDir, adtResult.Version);
            var viewerOutputDir = session.Paths.ViewerDir;
            
            var result = orchestrator.RunAnalysis(
                adtOutputDir,
                analysisOutputDir,
                viewerOutputDir,
                adtResult.Map,
                adtResult.Version,
                new AnalysisOptions());
            
            results.Add(result);
        }
        
        return new AnalysisStageResult(results);
    }
}
```

### Phase 5: Wire into PipelineOrchestrator

```csharp
// Update PipelineOrchestrator.Run()
ConsoleLogger.Info("Running analysis stage...");
var analysisRunner = new AnalysisStageRunner();
var analysisResults = analysisRunner.Run(session, adtResults);
if (analysisResults.Success)
{
    ConsoleLogger.Success($"Analysis complete: {analysisResults.OverlayCount} overlays generated");
}
```

---

## ‚úÖ Success Criteria

- [ ] UniqueID CSVs generated in `04_analysis/{version}/uniqueids/`
- [ ] MCNK terrain CSVs generated in `04_analysis/{version}/terrain/`
- [ ] Per-tile overlay JSONs generated in `05_viewer/overlays/{version}/{mapName}/`
- [ ] Overlay manifest created at `05_viewer/overlay_manifest.json`
- [ ] Viewer can load overlays via plugin architecture
- [ ] Time-travel slider can use uniqueID CSVs

---

## üìÖ Implementation Timeline

- **Day 1**: Create AnalysisModule project + AnalysisOrchestrator skeleton
- **Day 2**: Implement UniqueIdAnalyzer and TerrainCsvGenerator
- **Day 3**: Implement OverlayGenerator and OverlayManifestBuilder
- **Day 4**: Create AnalysisStageRunner and integrate into pipeline
- **Day 5**: Testing and validation with real data

---

## üîó Related Docs

- `03_Rollback_TimeTravel_Feature.md` - UniqueID analysis requirements
- `04_Overlay_Plugin_Architecture.md` - Plugin system design
- `04_Architecture_Changes.md` - Pipeline architecture
