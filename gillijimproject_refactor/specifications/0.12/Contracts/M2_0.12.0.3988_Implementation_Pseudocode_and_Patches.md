# M2 `0.12.0.3988` Support — Pseudocode + C# Patch Plan

## Goal
Add **real runtime support** for transitional M2 (`MD20`, version `0x100`) in the viewer/tooling pipeline, instead of treating it as generic/modern M2.

This patch plan is designed for:
- `src/MdxViewer/Terrain/FormatProfileRegistry.cs`
- `src/MdxViewer/ViewerApp.cs`
- `src/MdxViewer/Terrain/WorldScene.cs`
- `src/MdxViewer/Terrain/WorldAssetManager.cs`
- `src/WoWMapConverter/WoWMapConverter.Core/Converters/M2ToMdxConverter.cs`

---

## Key design decisions
1. `0x100` is **pre-modern** (256), not `v264+` (`0x108+`).
2. Route by container magic first (`MDLX` vs `MD20`) and then by build/version profile.
3. Add exact profile for `0.12.0.3988` and a guarded unknown fallback for early `0.x` MD20.
4. Keep conversion path (`M2 -> MDX`) but enforce profile/version checks before conversion.
5. Surface profile/build in logs and use `UnsupportedProfileFallbackCount` for fallback visibility.

---

## Pseudocode (runtime)

```text
function LoadModel(bytes, sourcePath, buildVersion):
  container = DetectContainer(bytes)

  if container == MDLX:
    parse with MDX path
    return

  if container == MD20:
    profile = ResolveModelProfile(buildVersion)

    if profile is null:
      // unknown build; infer by header version as guarded fallback
      md20Version = readUInt32(bytes, 4)
      if md20Version == 0x100:
        profile = M2Profile_01x_Unknown_PreModern
        increment UnsupportedProfileFallbackCount
      else:
        throw unsupported model profile

    validate magic/version against profile
    validate strict spans if profile.StrictSpanValidation

    mdxBytes = ConvertM2ToMdx(bytes, skinBytes, profile)
    load mdxBytes through existing MDX renderer path
    return

  throw unsupported container
```

---

## Patch 1 — Add dedicated transitional M2 profiles

File: `src/MdxViewer/Terrain/FormatProfileRegistry.cs`

```diff
@@
     public static readonly M2Profile M2Profile30xUnknown = new()
     {
         ProfileId = "M2Profile_30x_Unknown",
         RequiredRootMagic = ModelRootMagic.MD20,
@@
         EffectLikeAStride = 0xD4,
         EffectLikeBStride = 0x7C
     };
+
+    public static readonly M2Profile M2Profile0123988 = new()
+    {
+        ProfileId = "M2Profile_012_3988",
+        RequiredRootMagic = ModelRootMagic.MD20,
+        MinSupportedVersion = 0x100,
+        MaxSupportedVersion = 0x100,
+        UseTypedOffsetCountTable = true,
+        StrictSpanValidation = true,
+        VersionSplitThreshold = 0x108,
+        SkinLikeAStride = 0x2C,
+        SkinLikeBStride = 0x2C,
+        EffectLikeAStride = 0xD4,
+        EffectLikeBStride = 0x7C
+    };
+
+    public static readonly M2Profile M2Profile01xUnknownPreModern = new()
+    {
+        ProfileId = "M2Profile_01x_Unknown_PreModern",
+        RequiredRootMagic = ModelRootMagic.MD20,
+        MinSupportedVersion = 0x100,
+        MaxSupportedVersion = 0x103,
+        UseTypedOffsetCountTable = true,
+        StrictSpanValidation = true,
+        VersionSplitThreshold = 0x108,
+        SkinLikeAStride = 0x2C,
+        SkinLikeBStride = 0x2C,
+        EffectLikeAStride = 0xD4,
+        EffectLikeBStride = 0x7C
+    };
@@
     public static M2Profile? ResolveModelProfile(string? buildVersion)
     {
+        if (string.Equals(buildVersion, "0.12.0.3988", StringComparison.OrdinalIgnoreCase))
+            return M2Profile0123988;
+
+        if (string.Equals(buildVersion, "0.11.3925", StringComparison.OrdinalIgnoreCase))
+            return M2Profile01xUnknownPreModern;
+
+        if (string.Equals(buildVersion, "0.10.3892", StringComparison.OrdinalIgnoreCase))
+            return M2Profile01xUnknownPreModern;
+
         if (string.Equals(buildVersion, "3.3.5.12340", StringComparison.OrdinalIgnoreCase))
             return M2Profile33512340;
@@
         if (TryParseBuild(buildVersion, out int major, out int minor, out _, out _))
         {
+            if (major == 0 && minor >= 10 && minor <= 12)
+                return M2Profile01xUnknownPreModern;
+
             if (major == 3 && minor == 0)
                 return M2Profile30xUnknown;
         }
```

---

## Patch 2 — Plumb build/version into world model loading path

File: `src/MdxViewer/Terrain/WorldAssetManager.cs`

```diff
@@
 public class WorldAssetManager : IDisposable
 {
@@
     private readonly ReplaceableTextureResolver? _texResolver;
+    private readonly string? _buildVersion;
@@
-    public WorldAssetManager(GL gl, IDataSource? dataSource, ReplaceableTextureResolver? texResolver = null)
+    public WorldAssetManager(GL gl, IDataSource? dataSource, ReplaceableTextureResolver? texResolver = null, string? buildVersion = null)
     {
         _gl = gl;
         _dataSource = dataSource;
         _texResolver = texResolver;
+        _buildVersion = buildVersion;
     }
@@
     private MdxRenderer? LoadMdxModel(string normalizedKey)
     {
@@
-            if (data.Length >= 4 && BitConverter.ToUInt32(data, 0) == 0x3032444D)
+            if (data.Length >= 8 && BitConverter.ToUInt32(data, 0) == 0x3032444D)
             {
-                data = ConvertM2ToMdx(data, normalizedKey);
+                var modelProfile = FormatProfileRegistry.ResolveModelProfile(_buildVersion);
+                data = ConvertM2ToMdx(data, normalizedKey, modelProfile);
                 if (data == null) return null;
             }
@@
-    private byte[]? ConvertM2ToMdx(byte[] m2Bytes, string normalizedKey)
+    private byte[]? ConvertM2ToMdx(byte[] m2Bytes, string normalizedKey, M2Profile? modelProfile)
     {
         try
         {
+            uint magic = BitConverter.ToUInt32(m2Bytes, 0);
+            uint version = BitConverter.ToUInt32(m2Bytes, 4);
+            if (magic != 0x3032444D)
+                throw new InvalidDataException($"Not MD20: 0x{magic:X8}");
+
+            if (modelProfile != null)
+            {
+                if (version < modelProfile.MinSupportedVersion || version > modelProfile.MaxSupportedVersion)
+                    throw new InvalidDataException($"Unsupported MD20 version 0x{version:X} for profile {modelProfile.ProfileId}");
+            }
+            else
+            {
+                Build335Diagnostics.Increment("UnsupportedProfileFallbackCount");
+                ViewerLog.Important(ViewerLog.Category.Mdx,
+                    $"[M2] No build profile for '{_buildVersion ?? "unknown"}', using guarded fallback for {Path.GetFileName(normalizedKey)} (version=0x{version:X})");
+            }
+
             // Try to find companion .skin file (ModelName00.skin)
@@
             var converter = new M2ToMdxConverter();
-            byte[] mdxBytes = converter.ConvertToBytes(m2Bytes, skinBytes);
+            byte[] mdxBytes = converter.ConvertToBytes(m2Bytes, skinBytes, modelProfile, normalizedKey);
             ViewerLog.Trace($"[M2] Converted {Path.GetFileName(normalizedKey)}: {m2Bytes.Length} → {mdxBytes.Length} bytes");
             return mdxBytes;
         }
```

---

## Patch 3 — Pass build version from world creation to asset manager

File: `src/MdxViewer/Terrain/WorldScene.cs`

```diff
@@
 public WorldScene(GL gl, string wdtPath, IDataSource? dataSource,
     ReplaceableTextureResolver? texResolver = null,
+    string? buildVersion = null,
     Action<string>? onStatus = null)
 {
@@
-    _assets = new WorldAssetManager(gl, dataSource, texResolver);
+    _assets = new WorldAssetManager(gl, dataSource, texResolver, buildVersion);
@@
 public WorldScene(GL gl, TerrainManager terrainManager, IDataSource? dataSource,
     ReplaceableTextureResolver? texResolver = null,
+    string? buildVersion = null,
     Action<string>? onStatus = null)
 {
@@
-    _assets = new WorldAssetManager(gl, dataSource, texResolver);
+    _assets = new WorldAssetManager(gl, dataSource, texResolver, buildVersion);
```

File: `src/MdxViewer/ViewerApp.cs`

```diff
@@
 _worldScene = new WorldScene(_gl, wdtPath, _dataSource, _texResolver,
+    buildVersion: _dbcBuild,
     onStatus: OnLoadStatus);
@@
 _worldScene = new WorldScene(_gl, tm, _dataSource, _texResolver,
+    buildVersion: _dbcBuild,
     onStatus: OnLoadStatus);
```

---

## Patch 4 — Add profile-aware conversion entrypoint in converter

File: `src/WoWMapConverter/WoWMapConverter.Core/Converters/M2ToMdxConverter.cs`

```diff
@@
     public byte[] ConvertToBytes(byte[] m2Bytes, byte[]? skinBytes = null)
     {
@@
     }
+
+    public byte[] ConvertToBytes(byte[] m2Bytes, byte[]? skinBytes, MdxViewer.Terrain.M2Profile? profile, string? sourcePath)
+    {
+        try
+        {
+            if (m2Bytes.Length < 8)
+                throw new InvalidDataException("M2 buffer too small");
+
+            uint magic = BitConverter.ToUInt32(m2Bytes, 0);
+            uint version = BitConverter.ToUInt32(m2Bytes, 4);
+
+            if (magic != 0x3032444D)
+                throw new InvalidDataException($"Invalid M2 magic: 0x{magic:X8}");
+
+            if (profile != null)
+            {
+                if (version < profile.MinSupportedVersion || version > profile.MaxSupportedVersion)
+                    throw new InvalidDataException(
+                        $"M2 version 0x{version:X} is out of range for profile {profile.ProfileId} [{profile.MinSupportedVersion:X}..{profile.MaxSupportedVersion:X}] ({sourcePath ?? "<memory>"})");
+            }
+
+            return ConvertToBytes(m2Bytes, skinBytes);
+        }
+        catch
+        {
+            Build335Diagnostics.Increment("M2ConversionFailureCount");
+            throw;
+        }
+    }
```

> Note: if you do not want `WoWMapConverter.Core` to reference `MdxViewer.Terrain.M2Profile`, replace that parameter with a simple local DTO:
>
> ```csharp
> public sealed class M2ConversionContract
> {
>     public int MinSupportedVersion { get; init; }
>     public int MaxSupportedVersion { get; init; }
>     public string ProfileId { get; init; } = "";
> }
> ```

---

## Patch 5 — ViewerApp direct-load path guard (non-world model loads)

File: `src/MdxViewer/ViewerApp.cs`

```diff
@@
     private void LoadM2FromBytes(byte[] m2Bytes, string originalPath, string dir)
     {
+        if (m2Bytes.Length < 8)
+            throw new InvalidDataException("M2 file too small.");
+
+        uint magic = BitConverter.ToUInt32(m2Bytes, 0);
+        uint version = BitConverter.ToUInt32(m2Bytes, 4);
+        if (magic != 0x3032444D)
+            throw new InvalidDataException($"Invalid M2 magic: 0x{magic:X8}");
+
+        var modelProfile = FormatProfileRegistry.ResolveModelProfile(_dbcBuild);
+        if (modelProfile != null && (version < modelProfile.MinSupportedVersion || version > modelProfile.MaxSupportedVersion))
+        {
+            throw new InvalidDataException(
+                $"MD20 version 0x{version:X} does not match profile {modelProfile.ProfileId} for build {_dbcBuild ?? "unknown"}.");
+        }
+
         // Try to find companion .skin file
@@
         var converter = new M2ToMdxConverter();
-        byte[] mdxBytes = converter.ConvertToBytes(m2Bytes, skinBytes);
+        byte[] mdxBytes = converter.ConvertToBytes(m2Bytes, skinBytes, modelProfile, originalPath);
         ViewerLog.Trace($"[M2] Converted M2 ({m2Bytes.Length} bytes) → MDX ({mdxBytes.Length} bytes)");
```

---

## Validation pseudocode (post-patch)

```text
TestCase: build=0.12.0.3988, model magic=MD20, version=0x100
Expected:
  ResolveModelProfile(build) => M2Profile_012_3988
  version gate pass
  conversion succeeds

TestCase: build=0.12.0.3988, model magic=MD20, version=0x108
Expected:
  version gate fail with explicit message

TestCase: unknown build, MD20 version=0x100
Expected:
  fallback profile used
  UnsupportedProfileFallbackCount incremented
  conversion attempted with strict checks

TestCase: MDLX bytes with .mdx path
Expected:
  MDX path unchanged
```

---

## Why this is “proper support” for this version
- Adds explicit build-level contract for `0.12.0.3988` (not generic modern M2).
- Enforces pre-modern `0x100` expectations at runtime.
- Preserves existing MDX/MDLX behavior and container-first routing.
- Introduces guarded fallback path with diagnostics instead of silent coercion.

---

## Recommended next patch set (after this)
1. Add a dedicated transitional MD20 parser path (avoid conversion dependency), keyed by `M2Profile_012_3988`.
2. Move structural span checks from Ghidra-derived contracts into typed runtime validators (record families: `0x2C`, `0x30`, `0x38`, `0x54`, `0x6C`, `0x7C`, `0xD4`, `0xDC`, `0x1F8`).
3. Add per-family counters (parse-fail attribution by section family).
