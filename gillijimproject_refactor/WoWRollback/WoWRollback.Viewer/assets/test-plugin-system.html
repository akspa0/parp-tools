<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plugin System Test</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        #container {
            display: flex;
            height: 100vh;
        }
        
        #sidebar {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
        }
        
        #map {
            flex: 1;
            background: #0a0a0a;
        }
        
        h1 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #4CAF50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 4px;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .status {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
        }
        
        .status.success {
            border-left: 3px solid #4CAF50;
        }
        
        .status.error {
            border-left: 3px solid #F44336;
        }
        
        .info {
            background: #1e3a5f;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 12px;
        }
        
        pre {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1>üß™ Plugin System Test</h1>
            
            <div id="status" class="status">
                Initializing...
            </div>
            
            <div class="info">
                <strong>Test Objectives:</strong><br>
                ‚úì CoordinateSystem loads<br>
                ‚úì PluginManager initializes<br>
                ‚úì GridPlugin registers<br>
                ‚úì Grid displays correctly<br>
                ‚úì Plugin toggle works
            </div>
            
            <div class="info">
                <strong>Tile Numbering:</strong><br>
                ‚Ä¢ Grid: 64√ó64 (0-63)<br>
                ‚Ä¢ Row 0 = North (top)<br>
                ‚Ä¢ Row 63 = South (bottom)<br>
                ‚Ä¢ Col 0 = West (left)<br>
                ‚Ä¢ Col 63 = East (right)<br>
                ‚Ä¢ Center: Tile (32,32)
            </div>
            
            <div class="info">
                <strong>‚ö†Ô∏è Requirements:</strong><br>
                ‚Ä¢ Run via web server (not file://)<br>
                ‚Ä¢ Click "Simulate Tile Images" or "Load Real Kalimdor Tiles" for background map
            </div>
            
            <div id="dataStatus" class="info" style="background: #444; border-left: 3px solid #ff9800;">
                <strong>Data Status:</strong> <span id="dataStatusText">Checking...</span>
            </div>
            
            <div class="info">
                <strong>Plugin Controls:</strong>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="gridToggle" checked> Show ADT Grid
                </label>
                <label>
                    <input type="checkbox" id="chunkGridToggle"> Show Chunk Grid (16√ó16)
                </label>
                <label>
                    <input type="checkbox" id="densityToggle"> Show Density Heatmap
                </label>
                <label>
                    <input type="checkbox" id="tileLabelsToggle"> Show Tile Labels
                </label>
                <label>
                    <input type="checkbox" id="m2Toggle"> Show M2 Objects
                </label>
                <label>
                    <input type="checkbox" id="wmoToggle"> Show WMO Objects
                </label>
            </div>
            
            <button onclick="runCoordinateTests()">Run Coordinate Tests</button>
            <button onclick="testPluginLifecycle()">Test Plugin Lifecycle</button>
            <button onclick="logPluginState()">Log Plugin State</button>
            <button onclick="showDataStats()">Show Data Statistics</button>
            <button onclick="findHighDensityClusters()">Find High Density Clusters</button>
            <button onclick="simulateTiles()">Simulate Tile Images</button>
            <button onclick="loadRealTiles()">Load Real Kalimdor Tiles</button>
            <button onclick="clearSimulation()">Clear Simulation</button>
            
            <div id="testResults"></div>
        </div>
        
        <div id="map"></div>
        
        <!-- Mini-map overview (picture-in-picture) -->
        <canvas id="overviewCanvas" style="position: absolute; bottom: 20px; right: 20px; width: 200px; height: 200px; background: rgba(0,0,0,0.8); border: 2px solid #4CAF50; border-radius: 4px; cursor: crosshair;"></canvas>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script type="module">
        // Cache-busting version parameter (change this to force reload)
        const v = '20250109_0314';
        import { CoordinateSystem } from './js/core/CoordinateSystem.js?v=20250109_0314';
        import { PluginManager } from './js/core/PluginManager.js?v=20250109_0314';
        import { DataAdapter } from './js/core/DataAdapter.js?v=20250109_0314';
        import { GridPlugin } from './js/plugins/GridPlugin.js?v=20250109_0230';
        import { ChunkGridPlugin } from './js/plugins/ChunkGridPlugin.js?v=20250109_0230';
        import { TileLabelsPlugin } from './js/plugins/TileLabelsPlugin.js?v=20250109_0230';
        import { M2Plugin } from './js/plugins/M2Plugin.js?v=20250109_0230';
        import { WMOPlugin } from './js/plugins/WMOPlugin.js?v=20250109_0230';
        import { DensityHeatmapPlugin } from './js/plugins/DensityHeatmapPlugin.js?v=20250109_0230';
        import { runTests } from './js/tests/CoordinateSystem.test.js?v=20250109_0230';
        
        let map;
        let coordSystem;
        let pluginManager;
        let dataAdapter;
        let gridPlugin;
        let chunkGridPlugin;
        let tileLabelsPlugin;
        let m2Plugin;
        let wmoPlugin;
        let densityPlugin;
        
        // Initialize
        async function init() {
            try {
                updateStatus('Initializing coordinate system...', 'info');
                
                // Create coordinate system
                coordSystem = new CoordinateSystem({ coordMode: 'wowtools' });
                console.log('[Test] CoordinateSystem created:', coordSystem);
                
                // Create Leaflet map
                updateStatus('Creating Leaflet map...', 'info');
                map = L.map('map', {
                    crs: L.CRS.Simple,
                    minZoom: 0,
                    maxZoom: 12,
                    zoom: 2
                });
                map.setView([32, 32], 2);
                console.log('[Test] Leaflet map created');
                
                // Create custom pane for minimap tiles (lower z-index so overlays appear on top)
                map.createPane('tilesPane');
                map.getPane('tilesPane').style.zIndex = 100; // Below overlays (400+)
                console.log('[Test] Created tilesPane with z-index 100');
                
                // Create plugin manager
                updateStatus('Creating plugin manager...', 'info');
                pluginManager = new PluginManager(map, coordSystem);
                console.log('[Test] PluginManager created');
                
                // Load real data from pipeline output
                updateStatus('Loading real data...', 'info');
                dataAdapter = new DataAdapter();
                // Server running from session_YYYYMMDD_HHMMSS/, absolute path from server root
                const dataPath = '/04_analysis';
                // Change map here to match what you processed (Kalidar, Shadowfang, DeadminesInstance)
                const mapName = 'Kalidar';
                console.log('[Test] Attempting to load data from:', dataPath);
                console.log('[Test] Full URLs will be:');
                console.log(`  - ${dataPath}/0.5.3/master/${mapName}_master_index.json`);
                console.log(`  - ${dataPath}/0.5.3/master/${mapName}_id_ranges_by_tile.json`);
                
                const dataLoaded = await dataAdapter.loadMap('0.5.3', mapName, dataPath);
                const dataStatusEl = document.getElementById('dataStatusText');
                if (dataLoaded) {
                    const stats = dataAdapter.getStatistics();
                    console.log('[Test] ‚úÖ DataAdapter loaded:', stats);
                    updateStatus(`‚úÖ Loaded ${stats.totalObjects.toLocaleString()} objects (${stats.totalM2} M2, ${stats.totalWMO} WMO)`, 'success');
                    dataStatusEl.textContent = `‚úÖ ${stats.totalObjects.toLocaleString()} objects loaded (${stats.totalM2} M2, ${stats.totalWMO} WMO)`;
                    dataStatusEl.parentElement.style.borderLeftColor = '#4CAF50';
                } else {
                    console.error('[Test] ‚ùå DataAdapter failed to load');
                    console.error('[Test] Check browser console for fetch errors');
                    console.error('[Test] Make sure you are running a local web server (not file://)');
                    updateStatus('‚ùå Data load failed - check console', 'error');
                    dataStatusEl.textContent = '‚ùå Failed to load data - plugins will not display objects';
                    dataStatusEl.parentElement.style.borderLeftColor = '#f44336';
                }
                
                // Create and register plugins
                updateStatus('Registering plugins...', 'info');
                
                gridPlugin = new GridPlugin(map, coordSystem);
                pluginManager.register(gridPlugin);
                console.log('[Test] GridPlugin registered');
                
                chunkGridPlugin = new ChunkGridPlugin(map, coordSystem);
                pluginManager.register(chunkGridPlugin);
                console.log('[Test] ChunkGridPlugin registered');
                
                tileLabelsPlugin = new TileLabelsPlugin(map, coordSystem);
                pluginManager.register(tileLabelsPlugin);
                console.log('[Test] TileLabelsPlugin registered');
                
                m2Plugin = new M2Plugin(map, coordSystem, dataAdapter);
                pluginManager.register(m2Plugin);
                console.log('[Test] M2Plugin registered');
                
                wmoPlugin = new WMOPlugin(map, coordSystem, dataAdapter);
                pluginManager.register(wmoPlugin);
                console.log('[Test] WMOPlugin registered');
                
                densityPlugin = new DensityHeatmapPlugin(map, coordSystem, dataAdapter);
                pluginManager.register(densityPlugin);
                console.log('[Test] DensityHeatmapPlugin registered');
                
                // Enable and show grid by default
                updateStatus('Enabling grid...', 'info');
                gridPlugin.onEnable();
                gridPlugin.onShow();
                console.log('[Test] GridPlugin enabled and shown');
                
                // Setup UI
                setupUI();
                
                // Setup overview canvas
                setupOverview();
                
                updateStatus('‚úÖ Plugin system initialized successfully!', 'success');
                
                // Make available globally for testing
                window.map = map;
                window.coordSystem = coordSystem;
                window.pluginManager = pluginManager;
                window.dataAdapter = dataAdapter;
                window.gridPlugin = gridPlugin;
                window.chunkGridPlugin = chunkGridPlugin;
                window.tileLabelsPlugin = tileLabelsPlugin;
                window.m2Plugin = m2Plugin;
                window.wmoPlugin = wmoPlugin;
                window.densityPlugin = densityPlugin;
                
            } catch (error) {
                console.error('[Test] Initialization failed:', error);
                updateStatus('‚ùå Initialization failed: ' + error.message, 'error');
            }
        }
        
        function setupUI() {
            // Grid toggle
            const gridToggle = document.getElementById('gridToggle');
            gridToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    gridPlugin.onEnable();
                    gridPlugin.onShow();
                    console.log('[Test] Grid enabled');
                } else {
                    gridPlugin.onHide();
                    gridPlugin.onDisable();
                    console.log('[Test] Grid disabled');
                }
            });
            
            // Chunk grid toggle
            const chunkGridToggle = document.getElementById('chunkGridToggle');
            chunkGridToggle?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    chunkGridPlugin.onEnable();
                    chunkGridPlugin.onShow();
                    // Trigger initial load
                    const bounds = map.getBounds();
                    const zoom = map.getZoom();
                    chunkGridPlugin.loadVisibleData(bounds, zoom);
                    console.log('[Test] Chunk grid enabled');
                } else {
                    chunkGridPlugin.onHide();
                    chunkGridPlugin.onDisable();
                    console.log('[Test] Chunk grid disabled');
                }
            });
            
            // Density heatmap toggle
            const densityToggle = document.getElementById('densityToggle');
            densityToggle?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    densityPlugin.onEnable();
                    densityPlugin.onShow();
                    // Trigger initial load
                    const bounds = map.getBounds();
                    const zoom = map.getZoom();
                    densityPlugin.loadVisibleData(bounds, zoom);
                    console.log('[Test] Density heatmap enabled');
                } else {
                    densityPlugin.onHide();
                    densityPlugin.onDisable();
                    console.log('[Test] Density heatmap disabled');
                }
            });
            
            // Tile labels toggle
            const tileLabelsToggle = document.getElementById('tileLabelsToggle');
            tileLabelsToggle?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    tileLabelsPlugin.onEnable();
                    tileLabelsPlugin.onShow();
                    console.log('[Test] Tile labels enabled');
                } else {
                    tileLabelsPlugin.onHide();
                    tileLabelsPlugin.onDisable();
                    console.log('[Test] Tile labels disabled');
                }
            });
            
            // M2 objects toggle
            const m2Toggle = document.getElementById('m2Toggle');
            m2Toggle?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    m2Plugin.onEnable();
                    m2Plugin.onShow();
                    // Trigger initial load
                    const bounds = map.getBounds();
                    const zoom = map.getZoom();
                    m2Plugin.loadVisibleData(bounds, zoom);
                    console.log('[Test] M2 objects enabled');
                } else {
                    m2Plugin.onHide();
                    m2Plugin.onDisable();
                    console.log('[Test] M2 objects disabled');
                }
            });
            
            // WMO objects toggle
            const wmoToggle = document.getElementById('wmoToggle');
            wmoToggle?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    wmoPlugin.onEnable();
                    wmoPlugin.onShow();
                    // Trigger initial load
                    const bounds = map.getBounds();
                    const zoom = map.getZoom();
                    wmoPlugin.loadVisibleData(bounds, zoom);
                    console.log('[Test] WMO objects enabled');
                } else {
                    wmoPlugin.onHide();
                    wmoPlugin.onDisable();
                    console.log('[Test] WMO objects disabled');
                }
            });
            
            // Setup viewport change listener for lazy loading
            map.on('moveend zoomend', () => {
                const bounds = map.getBounds();
                const zoom = map.getZoom();
                
                if (chunkGridPlugin.enabled && chunkGridPlugin.visible) {
                    chunkGridPlugin.loadVisibleData(bounds, zoom);
                }
                if (densityPlugin.enabled && densityPlugin.visible) {
                    densityPlugin.loadVisibleData(bounds, zoom);
                }
                if (m2Plugin.enabled && m2Plugin.visible) {
                    m2Plugin.loadVisibleData(bounds, zoom);
                }
                if (wmoPlugin.enabled && wmoPlugin.visible) {
                    wmoPlugin.loadVisibleData(bounds, zoom);
                }
            });
        }
        
        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
        }
        
        function setupOverview() {
            const canvas = document.getElementById('overviewCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 200;
            
            function drawOverview() {
                ctx.clearRect(0, 0, 200, 200);
                
                // Draw 64x64 grid
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 1;
                
                const cellSize = 200 / 64;
                for (let i = 0; i <= 64; i++) {
                    const pos = i * cellSize;
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(pos, 0);
                    ctx.lineTo(pos, 200);
                    ctx.stroke();
                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(0, pos);
                    ctx.lineTo(200, pos);
                    ctx.stroke();
                }
                
                // Draw viewport indicator
                const bounds = map.getBounds();
                // Note: Leaflet Y increases downward, but we want row 0 at top
                const minRow = Math.max(0, Math.min(63, Math.floor(bounds.getSouth())));
                const maxRow = Math.max(0, Math.min(64, Math.ceil(bounds.getNorth())));
                const minCol = Math.max(0, Math.min(63, Math.floor(bounds.getWest())));
                const maxCol = Math.max(0, Math.min(64, Math.ceil(bounds.getEast())));
                
                ctx.fillStyle = 'rgba(255, 213, 79, 0.3)';
                ctx.fillRect(
                    minCol * cellSize,
                    minRow * cellSize,
                    (maxCol - minCol) * cellSize,
                    (maxRow - minRow) * cellSize
                );
                
                ctx.strokeStyle = '#FFD54F';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    minCol * cellSize,
                    minRow * cellSize,
                    (maxCol - minCol) * cellSize,
                    (maxRow - minRow) * cellSize
                );
            }
            
            // Update on map move
            map.on('moveend zoomend', drawOverview);
            drawOverview();
            
            // Click to center
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const col = Math.floor((x / 200) * 64);
                const row = Math.floor((y / 200) * 64);
                map.setView([row + 0.5, col + 0.5], map.getZoom());
            });
        }
        
        // Test functions (exposed globally)
        window.runCoordinateTests = function() {
            console.log('=== Running Coordinate System Tests ===');
            const results = runTests();
            
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = `
                <div class="status ${results.failed === 0 ? 'success' : 'error'}">
                    <strong>Test Results:</strong><br>
                    ‚úì Passed: ${results.passed}<br>
                    ${results.failed > 0 ? `‚úó Failed: ${results.failed}<br>` : ''}
                    Total: ${results.passed + results.failed}<br>
                    <br>
                    <em>Check browser console for detailed test output</em>
                </div>
            `;
        };
        
        window.testPluginLifecycle = function() {
            console.log('=== Testing Plugin Lifecycle ===');
            
            console.log('1. Disabling plugin...');
            gridPlugin.onDisable();
            
            setTimeout(() => {
                console.log('2. Enabling plugin...');
                gridPlugin.onEnable();
                
                setTimeout(() => {
                    console.log('3. Hiding plugin...');
                    gridPlugin.onHide();
                    
                    setTimeout(() => {
                        console.log('4. Showing plugin...');
                        gridPlugin.onShow();
                        
                        console.log('‚úì Lifecycle test complete');
                        updateStatus('‚úì Plugin lifecycle test passed', 'success');
                    }, 500);
                }, 500);
            }, 500);
        };
        
        window.logPluginState = function() {
            console.log('=== Plugin State ===');
            console.log('Plugin ID:', gridPlugin.id);
            console.log('Plugin Name:', gridPlugin.name);
            console.log('Enabled:', gridPlugin.enabled);
            console.log('Visible:', gridPlugin.visible);
            console.log('Opacity:', gridPlugin.opacity);
            console.log('Z-Index:', gridPlugin.zIndex);
            console.log('Layers:', gridPlugin.layers.length);
            console.log('Config:', gridPlugin.getConfig());
            
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = `
                <div class="status success">
                    <strong>Plugin State:</strong><br>
                    <pre>${JSON.stringify(gridPlugin.getConfig(), null, 2)}</pre>
                </div>
            `;
        };
        
        // Tile simulation
        let simulatedTiles = [];
        
        window.simulateTiles = function() {
            console.log('=== Simulating Tile Images ===');
            
            // Clear any existing simulation
            clearSimulation();
            
            // Create test tiles in a pattern to verify orientation
            // IMPORTANT: Leaflet row 0 = top, but we want WoW-style where row 0 = North
            // So we need to flip: WoW row 0 (North) ‚Üí Leaflet row 0 (top) ‚úì
            const testPatterns = [
                // Corner tiles - using Leaflet coordinates directly
                { row: 0, col: 0, color: '#FF0000', label: '0,0 (NW)' },      // Top-left
                { row: 0, col: 63, color: '#00FF00', label: '0,63 (NE)' },    // Top-right
                { row: 63, col: 0, color: '#0000FF', label: '63,0 (SW)' },    // Bottom-left
                { row: 63, col: 63, color: '#FFFF00', label: '63,63 (SE)' },  // Bottom-right
                
                // Center tiles
                { row: 31, col: 31, color: '#FF00FF', label: '31,31' },
                { row: 31, col: 32, color: '#00FFFF', label: '31,32' },
                { row: 32, col: 31, color: '#FFA500', label: '32,31' },
                { row: 32, col: 32, color: '#800080', label: '32,32 (CENTER)' },
                
                // Test row (horizontal line at row 20)
                { row: 20, col: 20, color: '#FFB6C1', label: '20,20' },
                { row: 20, col: 30, color: '#FFB6C1', label: '20,30' },
                { row: 20, col: 40, color: '#FFB6C1', label: '20,40' },
                
                // Test column (vertical line at col 40)
                { row: 25, col: 40, color: '#90EE90', label: '25,40' },
                { row: 35, col: 40, color: '#90EE90', label: '35,40' },
                { row: 45, col: 40, color: '#90EE90', label: '45,40' }
            ];
            
            testPatterns.forEach(pattern => {
                // Create SVG for this tile
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
                svg.setAttribute('viewBox', '0 0 100 100');
                
                // Background
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('width', '100');
                rect.setAttribute('height', '100');
                rect.setAttribute('fill', pattern.color);
                rect.setAttribute('opacity', '0.6');
                svg.appendChild(rect);
                
                // Border
                const border = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                border.setAttribute('width', '98');
                border.setAttribute('height', '98');
                border.setAttribute('x', '1');
                border.setAttribute('y', '1');
                border.setAttribute('fill', 'none');
                border.setAttribute('stroke', '#000');
                border.setAttribute('stroke-width', '2');
                svg.appendChild(border);
                
                // Label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '50');
                text.setAttribute('y', '50');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', '#000');
                text.textContent = pattern.label;
                svg.appendChild(text);
                
                // Create Leaflet overlay - put in tilesPane so it appears BEHIND grid/objects
                const bounds = coordSystem.tileBounds(pattern.row, pattern.col);
                const overlay = L.svgOverlay(svg, bounds, {
                    opacity: 1.0,
                    interactive: true,
                    pane: 'tilesPane' // Use custom pane with z-index 100
                });
                
                overlay.addTo(map);
                simulatedTiles.push(overlay);
                
                // Get the actual pixel position to verify
                const center = map.latLngToLayerPoint([pattern.row + 0.5, pattern.col + 0.5]);
                console.log(`  Tile ${pattern.label}:`);
                console.log(`    Requested: row=${pattern.row}, col=${pattern.col}`);
                console.log(`    Bounds: [[${bounds[0][0]}, ${bounds[0][1]}], [${bounds[1][0]}, ${bounds[1][1]}]]`);
                console.log(`    Center pixel: (${center.x}, ${center.y})`);
            });
            
            console.log(`‚úì Simulated ${testPatterns.length} tiles`);
            updateStatus(`‚úì Simulated ${testPatterns.length} test tiles`, 'success');
        };
        
        window.clearSimulation = function() {
            simulatedTiles.forEach(tile => tile.remove());
            simulatedTiles = [];
            console.log('‚úì Cleared tile simulation');
        };
        
        // Load real minimap tiles from the minimap directory
        window.loadRealTiles = function() {
            console.log('=== Loading All Minimap Tiles ===');
            
            // Clear any existing simulation
            clearSimulation();
            
            // Base path to the minimap tiles (absolute from server root at session_YYYYMMDD_HHMMSS/)
            // Change 'Kalidar' to match the map you're loading (Kalidar, Shadowfang, DeadminesInstance)
            const basePath = '/05_viewer/minimap/0.5.3/Kalidar';
            
            let loaded = 0;
            let failed = 0;
            const totalTiles = 64 * 64;
            
            // Load all 64x64 tiles
            for (let row = 0; row < 64; row++) {
                for (let col = 0; col < 64; col++) {
                    const mapName = 'Kalidar'; // Change to match basePath
                    const url = `${basePath}/${mapName}_${col}_${row}.webp`;
                    const bounds = coordSystem.tileBounds(row, col);
                    
                    const overlay = L.imageOverlay(url, bounds, {
                        opacity: 1.0,
                        interactive: false,
                        errorOverlayUrl: null,
                        pane: 'tilesPane' // Use custom pane with z-index 100
                    });
                    
                    overlay.on('load', () => {
                        loaded++;
                        if ((loaded + failed) % 100 === 0 || loaded + failed === totalTiles) {
                            console.log(`  Progress: ${loaded} loaded, ${failed} failed (${loaded + failed}/${totalTiles})`);
                            updateStatus(`Loading tiles: ${loaded}/${totalTiles} (${failed} failed)`, 'info');
                        }
                        if (loaded + failed === totalTiles) {
                            console.log(`‚úì Finished loading: ${loaded}/${totalTiles} tiles successfully`);
                            updateStatus(`‚úì Loaded ${loaded}/${totalTiles} tiles`, loaded > 0 ? 'success' : 'error');
                        }
                    });
                    
                    overlay.on('error', () => {
                        failed++;
                        if ((loaded + failed) % 100 === 0 || loaded + failed === totalTiles) {
                            console.log(`  Progress: ${loaded} loaded, ${failed} failed (${loaded + failed}/${totalTiles})`);
                            updateStatus(`Loading tiles: ${loaded}/${totalTiles} (${failed} failed)`, 'info');
                        }
                        if (loaded + failed === totalTiles) {
                            console.log(`‚úì Finished loading: ${loaded}/${totalTiles} tiles (${failed} failed)`);
                            updateStatus(`Loaded ${loaded}/${totalTiles} tiles (${failed} failed)`, loaded > 0 ? 'warning' : 'error');
                        }
                    });
                    
                    overlay.addTo(map);
                    simulatedTiles.push(overlay);
                }
            }
            
            console.log(`Attempting to load ${totalTiles} tiles from ${basePath}...`);
            updateStatus(`Loading ${totalTiles} tiles...`, 'info');
        };
        
        // Debug helper: check what's at a specific grid position
        window.checkGridPosition = function(row, col) {
            console.log(`=== Checking Grid Position (${row}, ${col}) ===`);
            const bounds = coordSystem.tileBounds(row, col);
            console.log(`  tileBounds: [[${bounds[0][0]}, ${bounds[0][1]}], [${bounds[1][0]}, ${bounds[1][1]}]]`);
            
            const center = map.latLngToLayerPoint([row + 0.5, col + 0.5]);
            console.log(`  Center pixel: (${center.x}, ${center.y})`);
            
            const latLng = coordSystem.tileToLatLng(row, col);
            console.log(`  tileToLatLng: (${latLng.lat}, ${latLng.lng})`);
            
            console.log(`  Expected grid label: ${row}_${col}`);
        };
        
        // Data analysis functions
        window.showDataStats = function() {
            if (!dataAdapter || !dataAdapter.masterIndex) {
                updateStatus('‚ùå No data loaded', 'error');
                return;
            }
            
            const stats = dataAdapter.getStatistics();
            console.log('=== Data Statistics ===');
            console.log('Map:', stats.map);
            console.log('Version:', stats.version);
            console.log('Generated:', stats.generatedAt);
            console.log('Total Objects:', stats.totalObjects.toLocaleString());
            console.log('  M2 Objects:', stats.totalM2.toLocaleString());
            console.log('  WMO Objects:', stats.totalWMO.toLocaleString());
            console.log('Total Tiles:', stats.totalTiles);
            console.log('Tiles with Data:', stats.tilesWithData);
            
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = `
                <div class="status success">
                    <strong>Data Statistics:</strong><br>
                    <strong>${stats.totalObjects.toLocaleString()} Total Objects</strong><br>
                    ${stats.totalM2.toLocaleString()} M2 Objects<br>
                    ${stats.totalWMO.toLocaleString()} WMO Objects<br>
                    <br>
                    ${stats.tilesWithData} tiles with data<br>
                    Generated: ${new Date(stats.generatedAt).toLocaleString()}<br>
                </div>
            `;
        };
        
        window.findHighDensityClusters = function() {
            if (!dataAdapter || !dataAdapter.idRanges) {
                updateStatus('‚ùå No ID ranges data loaded', 'error');
                return;
            }
            
            console.log('=== Finding High Density Clusters ===');
            const clusters = dataAdapter.getHighDensityChunks(10);
            console.log(`Found ${clusters.length} high-density chunks (‚â•10 objects)`);
            
            clusters.slice(0, 10).forEach((cluster, i) => {
                console.log(`${i + 1}. Tile ${cluster.tileX}_${cluster.tileY}, Chunk ${cluster.chunkX},${cluster.chunkY}: ${cluster.count} objects`);
                cluster.kinds.forEach(kind => {
                    console.log(`   - ${kind.kind}: ${kind.count}`);
                });
            });
            
            const prefabs = dataAdapter.analyzePrefabClusters(5);
            console.log(`\nPotential prefab clusters (mixed types): ${prefabs.length}`);
            prefabs.slice(0, 5).forEach((p, i) => {
                console.log(`${i + 1}. Tile ${p.tileX}_${p.tileY}, Chunk ${p.chunkX},${p.chunkY}: ${p.totalCount} objects`);
                p.composition.forEach(c => {
                    console.log(`   - ${c.kind}: ${c.count}`);
                });
            });
            
            const resultsDiv = document.getElementById('testResults');
            resultsDiv.innerHTML = `
                <div class="status success">
                    <strong>High Density Analysis:</strong><br>
                    ${clusters.length} chunks with ‚â•10 objects<br>
                    ${prefabs.length} potential prefab clusters<br>
                    <br>
                    Top hotspot: Tile ${clusters[0]?.tileX}_${clusters[0]?.tileY}<br>
                    Chunk ${clusters[0]?.chunkX},${clusters[0]?.chunkY}<br>
                    <strong>${clusters[0]?.count} objects</strong><br>
                    <br>
                    <em>See console for full list</em>
                </div>
            `;
        };
        
        // Auto-init
        init();
    </script>
</body>
</html>
