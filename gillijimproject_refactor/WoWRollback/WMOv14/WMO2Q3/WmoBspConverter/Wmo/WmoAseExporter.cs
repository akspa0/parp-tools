using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text;

namespace WmoBspConverter.Wmo;

/// <summary>
/// Exports WMO geometry to 3DS Max ASCII Scene Export (ASE) format.
/// ASE is natively supported by Q3Map via misc_model entities.
/// This is the same format Blizzard originally used for WMO creation.
/// </summary>
public class WmoAseExporter
{
    private readonly WmoTextureConverter _textureConverter = new();
    
    /// <summary>
    /// Export entire WMO to a single ASE file with all groups merged.
    /// </summary>
    public void ExportToAse(
        string outputPath,
        WmoV14Parser.WmoV14Data wmoData,
        string sourceWmoDir,
        bool convertTextures = true,
        bool verbose = false)
    {
        var outputDir = Path.GetDirectoryName(outputPath) ?? ".";
        Directory.CreateDirectory(outputDir);
        
        // Convert textures
        Dictionary<string, string> textureMap = new();
        if (convertTextures)
        {
            textureMap = _textureConverter.ConvertTextures(
                wmoData.Textures, sourceWmoDir, outputDir, verbose);
        }
        else
        {
            // Create identity mapping
            foreach (var tex in wmoData.Textures)
            {
                var baseName = Path.GetFileNameWithoutExtension(tex).ToLowerInvariant();
                textureMap[tex] = $"textures/wmo/{baseName}.tga";
            }
        }
        
        using var writer = new StreamWriter(outputPath, false, Encoding.ASCII);
        
        WriteHeader(writer);
        WriteMaterialList(writer, wmoData.Textures, textureMap);
        
        // Write each group as a GEOMOBJECT
        for (int i = 0; i < wmoData.Groups.Count; i++)
        {
            var group = wmoData.Groups[i];
            if (group.Vertices.Count == 0) continue;
            
            WriteGeomObject(writer, group, i, verbose);
        }
        
        Console.WriteLine($"[SUCCESS] Exported ASE: {outputPath}");
    }
    
    /// <summary>
    /// Export each WMO group as a separate ASE file.
    /// </summary>
    public void ExportGroupsToAse(
        string outputDir,
        string baseName,
        WmoV14Parser.WmoV14Data wmoData,
        string sourceWmoDir,
        bool convertTextures = true,
        bool verbose = false)
    {
        Directory.CreateDirectory(outputDir);
        
        // Convert textures once for all groups
        Dictionary<string, string> textureMap = new();
        if (convertTextures)
        {
            textureMap = _textureConverter.ConvertTextures(
                wmoData.Textures, sourceWmoDir, outputDir, verbose);
        }
        else
        {
            foreach (var tex in wmoData.Textures)
            {
                var bn = Path.GetFileNameWithoutExtension(tex).ToLowerInvariant();
                textureMap[tex] = $"textures/wmo/{bn}.tga";
            }
        }
        
        // Create models/wmo subdirectory for ASE files (Q3 expects this structure)
        var modelsDir = Path.Combine(outputDir, "models", "wmo");
        Directory.CreateDirectory(modelsDir);
        
        int exported = 0;
        for (int i = 0; i < wmoData.Groups.Count; i++)
        {
            var group = wmoData.Groups[i];
            if (group.Vertices.Count == 0)
            {
                if (verbose) Console.WriteLine($"[SKIP] Group {i} has no geometry");
                continue;
            }
            
            var groupFileName = $"{baseName}_group{i:D3}.ase";
            var groupPath = Path.Combine(modelsDir, groupFileName);
            
            using var writer = new StreamWriter(groupPath, false, Encoding.ASCII);
            
            WriteHeader(writer);
            WriteMaterialList(writer, wmoData.Textures, textureMap);
            WriteGeomObject(writer, group, i, verbose);
            
            Console.WriteLine($"[OK] Group {i}: {groupFileName} ({group.Vertices.Count} verts)");
            exported++;
        }
        
        Console.WriteLine($"[SUCCESS] Exported {exported} ASE files to {modelsDir}");
    }
    
    /// <summary>
    /// Generate a Q3 .map file referencing the exported ASE files as misc_model entities.
    /// </summary>
    public void GenerateQ3MapFile(
        string mapPath,
        string baseName,
        int groupCount,
        string modelsDir,
        Vector3 offset = default)
    {
        using var writer = new StreamWriter(mapPath, false, Encoding.ASCII);
        
        // Worldspawn with a simple room brush (Q3 requires at least one structural brush)
        writer.WriteLine("// Generated by WmoBspConverter - WMO to Q3 Map");
        writer.WriteLine("{");
        writer.WriteLine("\"classname\" \"worldspawn\"");
        
        // Optional: Add a simple hollow box brush to make q3map happy
        // This creates a 1 unit thick wall around a 8192 unit room
        writer.WriteLine("// World brush - hollow room");
        WriteSimpleBrush(writer, -8192, -8192, -8192, 8192, 8192, 8192, "common/caulk");
        
        writer.WriteLine("}");
        
        // Add misc_model entities for each group with absolute paths
        for (int i = 0; i < groupCount; i++)
        {
            // Use absolute path with forward slashes for cross-platform compatibility
            var asePath = Path.Combine(modelsDir, $"{baseName}_group{i:D3}.ase");
            var absolutePath = Path.GetFullPath(asePath).Replace('\\', '/');
            
            writer.WriteLine("{");
            writer.WriteLine("\"classname\" \"misc_model\"");
            writer.WriteLine($"\"model\" \"{absolutePath}\"");
            writer.WriteLine($"\"origin\" \"{offset.X} {offset.Y} {offset.Z}\"");
            writer.WriteLine("}");
        }
        
        Console.WriteLine($"[SUCCESS] Generated Q3 map: {mapPath}");
    }
    
    private void WriteHeader(StreamWriter w)
    {
        w.WriteLine("*3DSMAX_ASCIIEXPORT\t200");
        w.WriteLine("*COMMENT \"WMO to ASE export by WmoBspConverter\"");
        w.WriteLine($"*SCENE {{");
        w.WriteLine($"\t*SCENE_FILENAME \"wmo_export\"");
        w.WriteLine($"\t*SCENE_FIRSTFRAME 0");
        w.WriteLine($"\t*SCENE_LASTFRAME 0");
        w.WriteLine($"\t*SCENE_FRAMESPEED 30");
        w.WriteLine($"\t*SCENE_TICKSPERFRAME 160");
        w.WriteLine($"}}");
    }
    
    private void WriteMaterialList(
        StreamWriter w,
        List<string> textures,
        Dictionary<string, string> textureMap)
    {
        w.WriteLine($"*MATERIAL_LIST {{");
        // We use a single Multi/Sub-Object material to hold all textures
        // This allows *MESH_MTLID in the face list to select the correct texture
        w.WriteLine($"\t*MATERIAL_COUNT 1");
        
        w.WriteLine($"\t*MATERIAL 0 {{");
        w.WriteLine($"\t\t*MATERIAL_NAME \"GlobalMultiMat\"");
        w.WriteLine($"\t\t*MATERIAL_CLASS \"Multi/Sub-Object\"");
        w.WriteLine($"\t\t*NUMSUBMTLS {Math.Max(1, textures.Count)}");
        
        if (textures.Count == 0)
        {
            // Write a default sub-material
            w.WriteLine($"\t\t*SUBMATERIAL 0 {{");
            w.WriteLine($"\t\t\t*MATERIAL_NAME \"default\"");
            w.WriteLine($"\t\t\t*MAP_DIFFUSE {{");
            w.WriteLine($"\t\t\t\t*BITMAP \"textures/common/white.tga\"");
            w.WriteLine($"\t\t\t}}");
            w.WriteLine($"\t\t}}");
        }
        else
        {
            for (int i = 0; i < textures.Count; i++)
            {
                var origPath = textures[i];
                var q3Path = textureMap.TryGetValue(origPath, out var mapped) 
                    ? mapped 
                    : $"textures/wmo/{Path.GetFileNameWithoutExtension(origPath).ToLowerInvariant()}.tga";
                
                var matName = Path.GetFileNameWithoutExtension(origPath);
                
                w.WriteLine($"\t\t*SUBMATERIAL {i} {{");
                w.WriteLine($"\t\t\t*MATERIAL_NAME \"{matName}\"");
                w.WriteLine($"\t\t\t*MATERIAL_CLASS \"Standard\"");
                w.WriteLine($"\t\t\t*MAP_DIFFUSE {{");
                w.WriteLine($"\t\t\t\t*MAP_NAME \"Map #1\"");
                w.WriteLine($"\t\t\t\t*MAP_CLASS \"Bitmap\"");
                w.WriteLine($"\t\t\t\t*BITMAP \"{q3Path}\"");
                w.WriteLine($"\t\t\t}}");
                w.WriteLine($"\t\t}}");
            }
        }
        
        w.WriteLine($"\t}}"); // End Material 0
        w.WriteLine($"}}");      // End Material List
    }
    
    private void WriteGeomObject(
        StreamWriter w,
        WmoV14Parser.WmoGroupData group,
        int groupIndex,
        bool verbose)
    {
        var groupName = string.IsNullOrEmpty(group.Name) ? $"group_{groupIndex}" : group.Name;
        
        // Calculate face count
        int faceCount = group.Indices.Count / 3;
        int vertCount = group.Vertices.Count;
        int uvCount = group.UVs.Count;
        bool hasUVs = uvCount >= vertCount;
        
        if (verbose)
        {
            Console.WriteLine($"[DEBUG] Writing GEOMOBJECT: {groupName} ({vertCount} verts, {faceCount} faces)");
        }
        
        w.WriteLine($"*GEOMOBJECT {{");
        w.WriteLine($"\t*NODE_NAME \"{groupName}\"");
        
        // Node transform (identity)
        w.WriteLine($"\t*NODE_TM {{");
        w.WriteLine($"\t\t*NODE_NAME \"{groupName}\"");
        w.WriteLine($"\t\t*TM_ROW0 1.0 0.0 0.0");
        w.WriteLine($"\t\t*TM_ROW1 0.0 1.0 0.0");
        w.WriteLine($"\t\t*TM_ROW2 0.0 0.0 1.0");
        w.WriteLine($"\t\t*TM_ROW3 0.0 0.0 0.0");
        w.WriteLine($"\t\t*TM_POS 0.0 0.0 0.0");
        w.WriteLine($"\t}}");
        
        // Mesh data
        w.WriteLine($"\t*MESH {{");
        w.WriteLine($"\t\t*TIMEVALUE 0");
        w.WriteLine($"\t\t*MESH_NUMVERTEX {vertCount}");
        w.WriteLine($"\t\t*MESH_NUMFACES {faceCount}");
        
        // Vertex list - WMO to Q3 coordinate transform
        // WMO: Y-up, X-right, Z-forward (WoW uses Y-up)
        // Q3 aselib: swaps x/y and negates one axis
        // From aselib.c line 506-512: y = input.x, x = -input.y, z = input.z
        w.WriteLine($"\t\t*MESH_VERTEX_LIST {{");
        for (int i = 0; i < vertCount; i++)
        {
            var v = group.Vertices[i];
            // Transform: (x, y, z)_WMO â†’ (y, -x, z)_Q3
            float q3x = v.Y;
            float q3y = -v.X;
            float q3z = v.Z;
            w.WriteLine($"\t\t\t*MESH_VERTEX {i}\t{F(q3x)}\t{F(q3y)}\t{F(q3z)}");
        }
        w.WriteLine($"\t\t}}");
        
        // Face list
        w.WriteLine($"\t\t*MESH_FACE_LIST {{");
        for (int f = 0; f < faceCount; f++)
        {
            int i0 = group.Indices[f * 3 + 0];
            int i1 = group.Indices[f * 3 + 1];
            int i2 = group.Indices[f * 3 + 2];
            
            // Get material ID for this face
            int matId = 0;
            if (f < group.FaceMaterials.Count)
            {
                matId = group.FaceMaterials[f];
            }
            
            // Picomodel (pm_ase.c lines 694-696) reverses winding internally: stores C, B, A
            // So we output standard order A, B, C and let picomodel handle the reversal
            w.WriteLine($"\t\t\t*MESH_FACE {f}:\tA:\t{i0}\tB:\t{i1}\tC:\t{i2}\tAB:\t1\tBC:\t1\tCA:\t1\t*MESH_SMOOTHING 1\t*MESH_MTLID {matId}");
        }
        w.WriteLine($"\t\t}}");
        
        // Texture vertices (UVs)
        if (hasUVs)
        {
            w.WriteLine($"\t\t*MESH_NUMTVERTEX {uvCount}");
            w.WriteLine($"\t\t*MESH_TVERTLIST {{");
            for (int i = 0; i < uvCount; i++)
            {
                var uv = group.UVs[i];
                // Picomodel (pm_ase.c line 722) inverts T: texcoord[1] = 1.0f - texcoord[1]
                // We output UV as-is and let picomodel handle the inversion
                // If UV was pre-flipped in parser, we need to un-flip it here (1.0 - uv.Y)
                float finalV = 1.0f - uv.Y;  // Compensate for parser pre-flip + picomodel inversion
                w.WriteLine($"\t\t\t*MESH_TVERT {i}\t{F(uv.X)}\t{F(finalV)}\t0.0");
            }
            w.WriteLine($"\t\t}}");
            
            // Texture faces
            w.WriteLine($"\t\t*MESH_NUMTVFACES {faceCount}");
            w.WriteLine($"\t\t*MESH_TFACELIST {{");
            for (int f = 0; f < faceCount; f++)
            {
                // Use same indices as geometry faces
                // Picomodel (pm_ase.c lines 753-755) reverses winding internally
                // So we output standard order and let picomodel handle it
                int i0 = group.Indices[f * 3 + 0];
                int i1 = group.Indices[f * 3 + 1];
                int i2 = group.Indices[f * 3 + 2];
                
                // Clamp to UV array bounds
                i0 = Math.Min(i0, uvCount - 1);
                i1 = Math.Min(i1, uvCount - 1);
                i2 = Math.Min(i2, uvCount - 1);
                
                w.WriteLine($"\t\t\t*MESH_TFACE {f}\t{i0}\t{i1}\t{i2}");
            }
            w.WriteLine($"\t\t}}");
        }
        
        w.WriteLine($"\t}}");  // End MESH
        
        // Material reference (use first texture if available)
        w.WriteLine($"\t*MATERIAL_REF 0");
        
        w.WriteLine($"}}");  // End GEOMOBJECT
    }
    
    private void WriteSimpleBrush(StreamWriter w, float x1, float y1, float z1, float x2, float y2, float z2, string texture)
    {
        // Write a simple axis-aligned brush
        // This is a 6-sided box defined by 6 planes
        w.WriteLine("{");
        
        // Front plane  (+X)
        w.WriteLine($"( {x2} 0 0 ) ( {x2} 1 0 ) ( {x2} 0 1 ) {texture} 0 0 0 1 1");
        // Back plane   (-X)
        w.WriteLine($"( {x1} 0 0 ) ( {x1} 0 1 ) ( {x1} 1 0 ) {texture} 0 0 0 1 1");
        // Right plane  (+Y)
        w.WriteLine($"( 0 {y2} 0 ) ( 0 {y2} 1 ) ( 1 {y2} 0 ) {texture} 0 0 0 1 1");
        // Left plane   (-Y)
        w.WriteLine($"( 0 {y1} 0 ) ( 1 {y1} 0 ) ( 0 {y1} 1 ) {texture} 0 0 0 1 1");
        // Top plane    (+Z)
        w.WriteLine($"( 0 0 {z2} ) ( 1 0 {z2} ) ( 0 1 {z2} ) {texture} 0 0 0 1 1");
        // Bottom plane (-Z)
        w.WriteLine($"( 0 0 {z1} ) ( 0 1 {z1} ) ( 1 0 {z1} ) {texture} 0 0 0 1 1");
        
        w.WriteLine("}");
    }
    
    /// <summary>Format float with invariant culture</summary>
    private static string F(float v) => v.ToString("F6", CultureInfo.InvariantCulture);
}
