using System;
using System.Text;
using System.Numerics;
using System.IO;
using System.Collections.Generic;
using WmoBspConverter.Wmo;

namespace WmoBspConverter.Wmo;

public class WmoObjExporter
{
    private readonly WmoTextureConverter _textureConverter;

    public WmoObjExporter()
    {
        _textureConverter = new WmoTextureConverter();
    }

    public void ExportGroupsToObj(
        string outputDir,
        string baseName,
        WmoV14Parser.WmoV14Data wmoData,
        string sourceWmoDir,
        bool convertTextures = true,
        bool verbose = false)
    {
        Directory.CreateDirectory(outputDir);
        
        // Convert textures
        Dictionary<string, string> textureMap = new();
        if (convertTextures)
        {
            textureMap = _textureConverter.ConvertTextures(
                wmoData.Textures, sourceWmoDir, outputDir, verbose);
        }
        else
        {
            foreach (var tex in wmoData.Textures)
            {
                var bn = Path.GetFileNameWithoutExtension(tex).ToLowerInvariant();
                textureMap[tex] = $"textures/wmo/{bn}.tga";
            }
        }
        
        var modelsDir = Path.Combine(outputDir, "models", "wmo");
        Directory.CreateDirectory(modelsDir);
        
        // Write MTL file (one for all groups)
        var mtlFileName = $"{baseName}.mtl";
        var mtlPath = Path.Combine(modelsDir, mtlFileName);
        using (var mtlWriter = new StreamWriter(mtlPath, false, Encoding.ASCII))
        {
            WriteMaterialLib(mtlWriter, wmoData.Textures, textureMap);
        }
        
        int exported = 0;
        for (int i = 0; i < wmoData.Groups.Count; i++)
        {
            var group = wmoData.Groups[i];
            if (group.Vertices.Count == 0) continue;
            
            var groupFileName = $"{baseName}_group{i:D3}.obj";
            var groupPath = Path.Combine(modelsDir, groupFileName);
            
            using var writer = new StreamWriter(groupPath, false, Encoding.ASCII);
            
            writer.WriteLine($"# WMO group {i} export");
            writer.WriteLine($"mtllib {mtlFileName}");
            writer.WriteLine($"o {baseName}_group{i:D3}"); // Object name
            
            WriteMesh(writer, group, wmoData.Textures);
            
            if (verbose) Console.WriteLine($"[OK] Group {i}: {groupFileName} ({group.Vertices.Count} verts)");
            exported++;
        }
        
        Console.WriteLine($"[SUCCESS] Exported {exported} OBJ files to {modelsDir}");
    }

    public void GenerateQ3MapFile(
        string mapPath,
        string baseName,
        int groupCount,
        string modelsDir,
        Vector3 offset = default)
    {
        using var writer = new StreamWriter(mapPath, false, Encoding.ASCII);
        
        writer.WriteLine("// Generated by WmoBspConverter - WMO to Q3 Map (OBJ)");
        writer.WriteLine("{");
        writer.WriteLine("\"classname\" \"worldspawn\"");
        writer.WriteLine("// World brush - hollow room");
        // Simple hollow box
        WriteSimpleBrush(writer, -8192, -8192, -8192, 8192, 8192, 8192, "common/caulk");
        writer.WriteLine("}");
        
        for (int i = 0; i < groupCount; i++)
        {
            var modelPath = $"models/wmo/{baseName}_group{i:D3}.obj";
            
            writer.WriteLine("{");
            writer.WriteLine("\"classname\" \"misc_model\"");
            writer.WriteLine($"\"model\" \"{modelPath}\"");
            writer.WriteLine($"\"origin\" \"{F(offset.X)} {F(offset.Y)} {F(offset.Z)}\"");
            writer.WriteLine("}");
        }
    }

    private void WriteMaterialLib(
        StreamWriter w,
        List<string> textures,
        Dictionary<string, string> textureMap)
    {
        w.WriteLine("# Wavefront MTL");
        
        if (textures.Count == 0)
        {
            w.WriteLine("newmtl default");
            w.WriteLine("Kd 1.0 1.0 1.0");
            w.WriteLine("map_Kd textures/common/white.tga");
            return;
        }

        for (int i = 0; i < textures.Count; i++)
        {
            var tex = textures[i];
            var matName = Path.GetFileNameWithoutExtension(tex).Replace(" ", "_");
            var mapPath = textureMap.ContainsKey(tex) 
                ? textureMap[tex] 
                : $"textures/wmo/{Path.GetFileNameWithoutExtension(tex).ToLowerInvariant()}.tga";

            w.WriteLine($"newmtl {matName}");
            w.WriteLine("Kd 1.0 1.0 1.0");
            w.WriteLine("Ks 0.0 0.0 0.0");
            w.WriteLine("Ns 0");
            w.WriteLine($"map_Kd {mapPath}");
            w.WriteLine();
        }
    }

    private void WriteMesh(StreamWriter w, WmoV14Parser.WmoGroupData group, List<string> textures)
    {
        // 1. Vertices (v x y z)
        // Transform: (x, y, z)_WMO -> (y, -x, z)_Q3
        foreach (var v in group.Vertices)
        {
            float q3x = v.Y;
            float q3y = -v.X;
            float q3z = v.Z;
            w.WriteLine($"v {F(q3x)} {F(q3y)} {F(q3z)}");
        }

        // 2. UVs (vt u v)
        // WMO: (0,0) Top-Left. OpenGL/OBJ: (0,0) Bottom-Left.
        // Invert V: v = 1.0 - v
        foreach (var uv in group.UVs)
        {
            w.WriteLine($"vt {F(uv.X)} {F(1.0f - uv.Y)}");
        }

        // 3. Normals (vn x y z)
        // Transform same as vertices
        foreach (var n in group.Normals)
        {
            float q3x = n.Y;
            float q3y = -n.X;
            float q3z = n.Z;
            w.WriteLine($"vn {F(q3x)} {F(q3y)} {F(q3z)}");
        }

        // 4. Faces (f v/vt/vn ...)
        // OBJ indices are 1-based
        int currentMatId = -1;
        
        for (int f = 0; f < group.Indices.Count / 3; f++)
        {
            // Handle Material Switching
            int matId = 0;
            if (f < group.FaceMaterials.Count)
            {
                matId = group.FaceMaterials[f];
            }
            
            if (matId != currentMatId)
            {
                if (matId < textures.Count)
                {
                    var texName = textures[matId];
                    var materialName = Path.GetFileNameWithoutExtension(texName).Replace(" ", "_");
                    w.WriteLine($"usemtl {materialName}");
                }
                else
                {
                    w.WriteLine("usemtl default");
                }
                currentMatId = matId;
            }
            
            // Get indices (0-based)
            int i0 = group.Indices[f * 3 + 0];
            int i1 = group.Indices[f * 3 + 1];
            int i2 = group.Indices[f * 3 + 2];
            
            // Convert to 1-based for OBJ
            // Format: f v/vt/vn v/vt/vn v/vt/vn
            // WMO usually has matching count for verts/uvs/normals if flattened.
            // If UV/Normal counts differ, we must be careful.
            // WmoV14Parser flattens everything?
            // "The vertex array contains position data... The normals array contains normal data..."
            // Assuming 1:1 mapping for simplicty (common in game exports)
            
            // Verify winding!
            // WMO is often CCW or CW?
            // Previous ASE work: We established standard A,B,C order with picomodel reversing it internally.
            // OBJ standard is CCW.
            // WMO is ... ?
            // WMO (DirectX) is usually left-handed?
            // If we swapped axes (y, -x, z), we might have flipped winding?
            // Transformation:
            // x' = y
            // y' = -x
            // z' = z
            // Determinant of rotation matrix [0 1 0; -1 0 0; 0 0 1] is +1.
            // So it preserves chirality (handedness).
            // So if source is standard WMO, and destination is standard Q3 (Right Handed?),
            // We just output A,B,C.
            
            string v0 = $"{i0+1}/{i0+1}/{i0+1}";
            string v1 = $"{i1+1}/{i1+1}/{i1+1}";
            string v2 = $"{i2+1}/{i2+1}/{i2+1}";
            
            w.WriteLine($"f {v0} {v1} {v2}");
        }
    }
    
    // Helper to format floats
    private string F(float f) => f.ToString("0.000000", System.Globalization.CultureInfo.InvariantCulture);

    private void WriteSimpleBrush(StreamWriter w, int minX, int minY, int minZ, int maxX, int maxY, int maxZ, string texture)
    {
        // Simple rectangular brush format
        // ( x1 y1 z1 ) ( x2 y2 z2 ) ( x3 y3 z3 ) texture ...
        
        // Z planes
        w.WriteLine($"( {minX} {minY} {maxZ} ) ( {maxX} {minY} {maxZ} ) ( {maxX} {maxY} {maxZ} ) {texture} 0 0 0 0.5 0.5 0 0 0");
        w.WriteLine($"( {minX} {maxY} {minZ} ) ( {maxX} {maxY} {minZ} ) ( {maxX} {minY} {minZ} ) {texture} 0 0 0 0.5 0.5 0 0 0");
        
        // X planes
        w.WriteLine($"( {minX} {maxY} {maxZ} ) ( {minX} {maxY} {minZ} ) ( {minX} {minY} {minZ} ) {texture} 0 0 0 0.5 0.5 0 0 0");
        w.WriteLine($"( {maxX} {minY} {maxZ} ) ( {maxX} {minY} {minZ} ) ( {maxX} {maxY} {minZ} ) {texture} 0 0 0 0.5 0.5 0 0 0");
        
        // Y planes
        w.WriteLine($"( {maxX} {minY} {maxZ} ) ( {minX} {minY} {maxZ} ) ( {minX} {minY} {minZ} ) {texture} 0 0 0 0.5 0.5 0 0 0");
        w.WriteLine($"( {maxX} {maxY} {minZ} ) ( {minX} {maxY} {minZ} ) ( {minX} {maxY} {maxZ} ) {texture} 0 0 0 0.5 0.5 0 0 0");
    }
}
