using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Numerics;
using System.Text;

namespace WmoBspConverter.Export
{
    public sealed class AseWriter
    {
        private static Vector3 TransformToQ3(Vector3 v)
        {
            return new Vector3(v.X, v.Y, v.Z);
        }

        public sealed record ExportResult(
            string RelativeModelPath,
            Vector3 RoomCenter,
            Vector3 RoomMin,
            Vector3 RoomMax,
            Vector3 MapOffset);

        public ExportResult ExportGroup(
            string outputRootDir,
            string wmoName,
            int groupIndex,
            IReadOnlyList<Vector3> vertices,
            IReadOnlyList<int> indices,
            IReadOnlyList<int> faceMaterials,
            IReadOnlyList<string> shaderNames,
            Vector3 mapOffset)
        {
            if (vertices.Count == 0 || indices.Count < 3)
            {
                // Still emit an empty model to keep references stable; center at origin
                var emptyRel = Path.Combine("models", "wmo", wmoName, $"group_{groupIndex:D3}.ase").Replace('\\', '/');
                var emptyAbs = Path.Combine(outputRootDir, emptyRel);
                Directory.CreateDirectory(Path.GetDirectoryName(emptyAbs)!);
                File.WriteAllText(emptyAbs, BuildEmptyAse(groupIndex, shaderNames));
                return new ExportResult(emptyRel, Vector3.Zero, Vector3.Zero, Vector3.Zero, mapOffset);
            }

            // Transform vertices to room space and compute centroid
            var vertsRoom = new Vector3[vertices.Count];
            var sum = Vector3.Zero;
            var roomMin = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
            var roomMax = new Vector3(float.MinValue, float.MinValue, float.MinValue);
            for (int i = 0; i < vertices.Count; i++)
            {
                var q = TransformToQ3(vertices[i]);
                var room = q - mapOffset;
                vertsRoom[i] = room;
                sum += room;
                roomMin = Vector3.Min(roomMin, room);
                roomMax = Vector3.Max(roomMax, room);
            }
            var center = sum / vertices.Count;

            if (groupIndex < 3)
            {
                Console.WriteLine($"[DEBUG] ASE group {groupIndex} bounds room min={roomMin}, max={roomMax}, center={center}");
            }

            // Recenter vertices around origin
            for (int i = 0; i < vertsRoom.Length; i++)
            {
                vertsRoom[i] -= center;
            }

            var relPath = Path.Combine("models", "wmo", wmoName, $"group_{groupIndex:D3}.ase").Replace('\\', '/');
            var absPath = Path.Combine(outputRootDir, relPath);
            Directory.CreateDirectory(Path.GetDirectoryName(absPath)!);

            var ase = BuildAse(groupIndex, vertsRoom, indices, faceMaterials, shaderNames);
            File.WriteAllText(absPath, ase);

            return new ExportResult(relPath, center, roomMin, roomMax, mapOffset);
        }

        private static string BuildEmptyAse(int groupIndex, IReadOnlyList<string> shaderNames)
        {
            var sb = new StringBuilder();
            sb.AppendLine("*3DSMAX_ASCIIEXPORT 200");
            sb.AppendLine("*COMMENT \"Generated by WmoBspConverter\"");
            AppendMaterials(sb, shaderNames);
            sb.AppendLine("*GEOMOBJECT {\n  *NODE_NAME \"group_" + groupIndex.ToString("D3") + "\"\n  *MESH {\n    *TIMEVALUE 0\n    *MESH_NUMVERTEX 0\n    *MESH_NUMFACES 0\n    *MESH_VERTEX_LIST { }\n    *MESH_FACE_LIST { }\n  }\n  *MATERIAL_REF 0\n}");
            return sb.ToString();
        }

        private static string BuildAse(
            int groupIndex,
            IReadOnlyList<Vector3> verts,
            IReadOnlyList<int> indices,
            IReadOnlyList<int> faceMaterials,
            IReadOnlyList<string> shaderNames)
        {
            var sb = new StringBuilder();
            sb.AppendLine("*3DSMAX_ASCIIEXPORT 200");
            sb.AppendLine("*COMMENT \"Generated by WmoBspConverter\"");
            AppendMaterials(sb, shaderNames);
            sb.AppendLine("*GEOMOBJECT {");
            sb.AppendLine("  *NODE_NAME \"group_" + groupIndex.ToString("D3") + "\"");
            sb.AppendLine("  *MESH {");
            sb.AppendLine("    *TIMEVALUE 0");
            sb.AppendLine("    *MESH_NUMVERTEX " + verts.Count.ToString(CultureInfo.InvariantCulture));
            sb.AppendLine("    *MESH_NUMFACES " + (indices.Count / 3).ToString(CultureInfo.InvariantCulture));
            sb.AppendLine("    *MESH_VERTEX_LIST {");
            for (int i = 0; i < verts.Count; i++)
            {
                var v = verts[i];
                sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                    "      *MESH_VERTEX {0} {1:F6} {2:F6} {3:F6}", i, v.X, v.Y, v.Z));
            }
            sb.AppendLine("    }");
            sb.AppendLine("    *MESH_FACE_LIST {");
            var faceCount = indices.Count / 3;
            for (int f = 0; f < faceCount; f++)
            {
                int i0 = indices[f * 3 + 0];
                int i1 = indices[f * 3 + 1];
                int i2 = indices[f * 3 + 2];
                var mtlId = 0;
                if (faceMaterials.Count > f)
                {
                    mtlId = Math.Clamp(faceMaterials[f], 0, Math.Max(0, shaderNames.Count - 1));
                }
                // ASE face line: index, A/B/C with vertex indices, and flags. Keep flags zero.
                sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                    "      *MESH_FACE {0}: A: {1} B: {2} C: {3} AB: 0 BC: 0 CA: 0 *MESH_MTLID {4}",
                    f, i0, i1, i2, mtlId));
            }
            sb.AppendLine("    }");
            sb.AppendLine("  }");
            sb.AppendLine("  *MATERIAL_REF 0");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static void AppendMaterials(StringBuilder sb, IReadOnlyList<string> shaderNames)
        {
            var count = shaderNames.Count > 0 ? shaderNames.Count : 1;
            sb.AppendLine("*MATERIAL_LIST {");
            sb.AppendLine($"  *MATERIAL_COUNT {count}");
            if (shaderNames.Count == 0)
            {
                sb.AppendLine("  *MATERIAL 0 {");
                sb.AppendLine("    *MATERIAL_NAME \"wmo_default\"");
                sb.AppendLine("    *MATERIAL_CLASS \"Standard\"");
                sb.AppendLine("    *MAP_DIFFUSE {");
                sb.AppendLine("      *MAP_NAME \"wmo_default\"");
                sb.AppendLine("      *MAP_CLASS \"Bitmap\"");
                sb.AppendLine("      *BITMAP \"textures/common/caulk\"");
                sb.AppendLine("    }");
                sb.AppendLine("  }");
            }
            else
            {
                for (int i = 0; i < shaderNames.Count; i++)
                {
                    var baseName = shaderNames[i];
                    if (string.IsNullOrWhiteSpace(baseName))
                    {
                        baseName = "textures/wmo/wmo_default";
                    }
                    var shader = baseName; // use shader name as provided (e.g., textures/wmo/<name>)
                    var bitmap = $"{shader}.tga";
                    sb.AppendLine($"  *MATERIAL {i} {{");
                    sb.AppendLine($"    *MATERIAL_NAME \"{shader}\"");
                    sb.AppendLine("    *MATERIAL_CLASS \"Standard\"");
                    sb.AppendLine("    *MAP_DIFFUSE {");
                    sb.AppendLine($"      *MAP_NAME \"{shader}\"");
                    sb.AppendLine("      *MAP_CLASS \"Bitmap\"");
                    sb.AppendLine($"      *BITMAP \"{bitmap}\"");
                    sb.AppendLine("    }");
                    sb.AppendLine("  }");
                }
            }
            sb.AppendLine("}");
        }
    }

    public sealed record ModelPlacement(string ModelRelPath, Vector3 OriginQ3, int GroupIndex);
}
