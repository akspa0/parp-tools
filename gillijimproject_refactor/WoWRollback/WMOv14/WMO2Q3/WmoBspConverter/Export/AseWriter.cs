using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Numerics;
using System.Text;

namespace WmoBspConverter.Export
{
    public sealed class AseWriter
    {
        private static Vector3 TransformToQ3(Vector3 v)
        {
            return new Vector3(v.X, -v.Z, v.Y);
        }

        public sealed record ExportResult(string RelativeModelPath, Vector3 ModelOrigin);

        public ExportResult ExportGroup(
            string outputRootDir,
            string wmoName,
            int groupIndex,
            IReadOnlyList<Vector3> vertices,
            IReadOnlyList<int> indices,
            Vector3 mapOffset)
        {
            if (vertices.Count == 0 || indices.Count < 3)
            {
                // Still emit an empty model to keep references stable; center at origin
                var emptyRel = Path.Combine("models", "wmo", wmoName, $"group_{groupIndex:D3}.ase").Replace('\\', '/');
                var emptyAbs = Path.Combine(outputRootDir, emptyRel);
                Directory.CreateDirectory(Path.GetDirectoryName(emptyAbs)!);
                File.WriteAllText(emptyAbs, BuildEmptyAse(groupIndex));
                return new ExportResult(emptyRel, Vector3.Zero);
            }

            // Transform vertices to Q3 and compute center
            var vertsRoom = new Vector3[vertices.Count];
            var min = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
            var max = new Vector3(float.MinValue, float.MinValue, float.MinValue);
            for (int i = 0; i < vertices.Count; i++)
            {
                var q = TransformToQ3(vertices[i]);
                var room = q - mapOffset;
                vertsRoom[i] = room;
                min = Vector3.Min(min, room);
                max = Vector3.Max(max, room);
            }
            var center = (min + max) * 0.5f;

            // Recenter vertices around origin
            for (int i = 0; i < vertsRoom.Length; i++)
            {
                vertsRoom[i] -= center;
            }

            var relPath = Path.Combine("models", "wmo", wmoName, $"group_{groupIndex:D3}.ase").Replace('\\', '/');
            var absPath = Path.Combine(outputRootDir, relPath);
            Directory.CreateDirectory(Path.GetDirectoryName(absPath)!);

            var ase = BuildAse(groupIndex, vertsRoom, indices);
            File.WriteAllText(absPath, ase);

            return new ExportResult(relPath, center);
        }

        private static string BuildEmptyAse(int groupIndex)
        {
            var sb = new StringBuilder();
            sb.AppendLine("*3DSMAX_ASCIIEXPORT 200");
            sb.AppendLine("*COMMENT \"Generated by WmoBspConverter\"");
            sb.AppendLine("*MATERIAL_LIST {\n  *MATERIAL_COUNT 1\n  *MATERIAL 0 {\n    *MATERIAL_NAME \"wmo_default\"\n    *MATERIAL_CLASS \"Standard\"\n    *MAP_DIFFUSE {\n      *MAP_NAME \"wmo_default\"\n      *MAP_CLASS \"Bitmap\"\n      *BITMAP \"textures/common/caulk\"\n    }\n  }\n}");
            sb.AppendLine("*GEOMOBJECT {\n  *NODE_NAME \"group_" + groupIndex.ToString("D3") + "\"\n  *MESH {\n    *TIMEVALUE 0\n    *MESH_NUMVERTEX 0\n    *MESH_NUMFACES 0\n    *MESH_VERTEX_LIST { }\n    *MESH_FACE_LIST { }\n  }\n  *MATERIAL_REF 0\n}");
            return sb.ToString();
        }

        private static string BuildAse(int groupIndex, IReadOnlyList<Vector3> verts, IReadOnlyList<int> indices)
        {
            var sb = new StringBuilder();
            sb.AppendLine("*3DSMAX_ASCIIEXPORT 200");
            sb.AppendLine("*COMMENT \"Generated by WmoBspConverter\"");
            sb.AppendLine("*MATERIAL_LIST {\n  *MATERIAL_COUNT 1\n  *MATERIAL 0 {\n    *MATERIAL_NAME \"wmo_default\"\n    *MATERIAL_CLASS \"Standard\"\n    *MAP_DIFFUSE {\n      *MAP_NAME \"wmo_default\"\n      *MAP_CLASS \"Bitmap\"\n      *BITMAP \"textures/common/caulk\"\n    }\n  }\n}");
            sb.AppendLine("*GEOMOBJECT {");
            sb.AppendLine("  *NODE_NAME \"group_" + groupIndex.ToString("D3") + "\"");
            sb.AppendLine("  *MESH {");
            sb.AppendLine("    *TIMEVALUE 0");
            sb.AppendLine("    *MESH_NUMVERTEX " + verts.Count.ToString(CultureInfo.InvariantCulture));
            sb.AppendLine("    *MESH_NUMFACES " + (indices.Count / 3).ToString(CultureInfo.InvariantCulture));
            sb.AppendLine("    *MESH_VERTEX_LIST {");
            for (int i = 0; i < verts.Count; i++)
            {
                var v = verts[i];
                sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                    "      *MESH_VERTEX {0} {1:F6} {2:F6} {3:F6}", i, v.X, v.Y, v.Z));
            }
            sb.AppendLine("    }");
            sb.AppendLine("    *MESH_FACE_LIST {");
            var faceCount = indices.Count / 3;
            for (int f = 0; f < faceCount; f++)
            {
                int i0 = indices[f * 3 + 0];
                int i1 = indices[f * 3 + 1];
                int i2 = indices[f * 3 + 2];
                // ASE face line: index, A/B/C with vertex indices, and flags. Keep flags zero.
                sb.AppendLine(string.Format(CultureInfo.InvariantCulture,
                    "      *MESH_FACE {0}: A: {1} B: {2} C: {3} AB: 0 BC: 0 CA: 0 *MESH_MTLID 0",
                    f, i0, i1, i2));
            }
            sb.AppendLine("    }");
            sb.AppendLine("  }");
            sb.AppendLine("  *MATERIAL_REF 0");
            sb.AppendLine("}");
            return sb.ToString();
        }
    }

    public sealed record ModelPlacement(string ModelRelPath, Vector3 OriginQ3, int GroupIndex);
}
