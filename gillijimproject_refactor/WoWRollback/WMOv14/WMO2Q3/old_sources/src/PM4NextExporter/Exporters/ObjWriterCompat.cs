using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Numerics;

namespace PM4NextExporter.Exporters
{
    internal static class ObjWriterCompat
    {
        // Writes an OBJ with PM4FacesTool-compatible formatting and triangle winding adjustments.
        // Returns (Written, Skipped) face counts for caller summaries.
        public static (int Written, int Skipped) Write(
            string path,
            IReadOnlyList<Vector3> vertices,
            IReadOnlyList<(int A, int B, int C)> triangles,
            bool legacyParity,
            bool projectLocal,
            bool forceFlipX = false,
            bool centeredMirrorX = false)
        {
            Directory.CreateDirectory(Path.GetDirectoryName(path)!);

            int vCount = vertices?.Count ?? 0;
            var verts = new Vector3[vCount];

            if (vertices != null)
            {
                if (projectLocal && vCount > 0)
                {
                    var mean = ComputeMean(vertices);
                    for (int i = 0; i < vCount; i++) verts[i] = vertices[i] - mean;
                }
                else
                {
                    for (int i = 0; i < vCount; i++) verts[i] = vertices[i];
                }
            }

            bool flip = legacyParity || forceFlipX;

            float centerRelX = 0f;
            if (centeredMirrorX && flip && vCount > 0)
            {
                double sx = 0;
                for (int i = 0; i < vCount; i++) sx += verts[i].X;
                var centerX = (float)(sx / vCount);
                centerRelX = centerX; // since verts already project-local translated if requested
            }

            if (flip)
            {
                for (int i = 0; i < vCount; i++)
                {
                    var v = verts[i];
                    float x = centeredMirrorX ? (2f * centerRelX - v.X) : -v.X;
                    verts[i] = new Vector3(x, v.Y, v.Z);
                }
            }

            using var sw = new StreamWriter(path);
            var ci = CultureInfo.InvariantCulture;

            sw.WriteLine("# Generated by PM4NextExporter");
            sw.WriteLine("# vertices {0}", vCount);
            sw.WriteLine("# faces {0}", triangles?.Count ?? 0);

            string objName = Path.GetFileNameWithoutExtension(path);
            if (!string.IsNullOrWhiteSpace(objName))
            {
                var safe = SafeName(objName);
                sw.WriteLine("o {0}", safe);
                sw.WriteLine("g {0}", safe);
            }

            // vertices
            for (int i = 0; i < vCount; i++)
            {
                var v = verts[i];
                sw.Write("v ");
                sw.Write(v.X.ToString("G9", ci)); sw.Write(' ');
                sw.Write(v.Y.ToString("G9", ci)); sw.Write(' ');
                sw.Write(v.Z.ToString("G9", ci)); sw.WriteLine();
            }

            // faces (1-based)
            int written = 0, skipped = 0;
            int tCount = triangles?.Count ?? 0;
            for (int i = 0; i < tCount; i++)
            {
                var (a, b, c) = triangles![i];
                if (!IsValidIndex(a, vCount) || !IsValidIndex(b, vCount) || !IsValidIndex(c, vCount))
                {
                    skipped++;
                    continue;
                }

                if (flip)
                {
                    // swap to preserve normals under X mirror
                    (b, c) = (c, b);
                }

                sw.Write("f ");
                sw.Write((a + 1).ToString(ci)); sw.Write(' ');
                sw.Write((b + 1).ToString(ci)); sw.Write(' ');
                sw.Write((c + 1).ToString(ci)); sw.WriteLine();
                written++;
            }

            return (written, skipped);
        }

        private static Vector3 ComputeMean(IReadOnlyList<Vector3> vertices)
        {
            double sx = 0, sy = 0, sz = 0;
            int n = vertices.Count;
            for (int i = 0; i < n; i++)
            {
                sx += vertices[i].X;
                sy += vertices[i].Y;
                sz += vertices[i].Z;
            }
            double inv = 1.0 / Math.Max(1, n);
            return new Vector3((float)(sx * inv), (float)(sy * inv), (float)(sz * inv));
        }

        private static bool IsValidIndex(int i, int count) => i >= 0 && i < count;

        private static string SafeName(string name)
        {
            var invalid = Path.GetInvalidFileNameChars();
            var s = string.Join("_", name.Split(invalid, StringSplitOptions.RemoveEmptyEntries)).TrimEnd('.');
            return string.IsNullOrWhiteSpace(s) ? "object" : s;
        }
    }
}
