[["CMapChunk::Render"], {"CMapChunk": "numLayers;\n    \n    // Render each layer\n    for (int i = 0; i < numLayers; i++) {\n        // Get layer\n        CMapChunkLayer* layer = &chunk->layers[i];\n        \n        // Set up texture\n        GxTextureSet(0, layer->textureId);\n        \n        // Set up alpha map\n        GxTextureSet(1, layer->alphaMapId);\n        \n        // Set up blend mode\n        GxBlendSet(layer->blendMode);\n        \n        // Render layer\n        RenderLayer(chunk, layer);\n        \n        // Push render state for subsequent layers\n        if (i > 0) {\n            GxRenderStatePush();\n        }\n    }\n    \n    // Pop render states for all but first layer\n    for (int i = 1; i < numLayers; i++) {\n        GxRenderStatePop();\n    }\n}\n\nvoid RenderLayer(CMapChunk* chunk, CMapChunkLayer* layer) {\n    // Set up vertex shader\n    GxVertexShaderSet(layer->vertexShader);\n    \n    // Set up pixel shader\n    GxPixelShaderSet(layer->pixelShader);\n    \n    // Set up texture coordinates\n    GxTexCoordSet(0, layer->texCoord0);\n    GxTexCoordSet(1, layer->texCoord1);\n    \n    // Draw triangles\n    GxDrawTriangles(chunk->vertexBuffer, chunk->indexBuffer);\n}\n```\n\n## Layer Blending\n\n### Blend Modes\n\n```c\nenum BlendMode {\n    BLEND_OPAQUE = 4,      // Opaque (no blending)\n    BLEND_ALPHA = 0,       // Alpha blending\n    BLEND_ADD = 1,         // Additive blending\n    BLEND_MODULATE = 2,    // Modulate blending\n    BLEND_MODULATE2X = 3   // Modulate 2X blending\n};\n```\n\n### Alpha Blending\n\n```c\n// Alpha blending formula\nfinalColor = srcColor * srcAlpha + dstColor * (1 - srcAlpha)\n```\n\n### Additive Blending\n\n```c\n// Additive blending formula\nfinalColor = srcColor * srcAlpha + dstColor\n```\n\n### Modulate Blending\n\n```c\n// Modulate blending formula\nfinalColor = srcColor * dstColor\n```\n\n### Modulate 2X Blending\n\n```c\n// Modulate 2X blending formula\nfinalColor = srcColor * dstColor * 2\n```\n\n## Alpha Maps\n\n### Alpha Map Structure\n\n```c\nstruct AlphaMap {\n    uint width;      // Width of alpha map (usually 64)\n    uint height;     // Height of alpha map (usually 64)\n    byte* data;      // Alpha values (0-255)\n};\n```\n\n### Alpha Map Usage\n\n```c\n// Sample alpha map at texture coordinates\nfloat SampleAlphaMap(AlphaMap* alphaMap, float u, float v) {\n    // Convert UV to pixel coordinates\n    int x = (int)(u * alphaMap->width);\n    int y = (int)(v * alphaMap->height);\n    \n    // Clamp to valid range\n    x = Clamp(x, 0, alphaMap->width - 1);\n    y = Clamp(y, 0, alphaMap->height - 1);\n    \n    // Get alpha value\n    return alphaMap->data[y * alphaMap->width + x] / 255.0f;\n}\n```\n\n## Texture Coordinates\n\n### Texture Coordinate 0\n\n```c\n// Texture coordinate 0 (base texture)\nstruct TexCoord0 {\n    float u;  // U coordinate\n    float v;  // V coordinate\n};\n```\n\n### Texture Coordinate 1\n\n```c\n// Texture coordinate 1 (detail texture)\nstruct TexCoord1 {\n    float u;  // U coordinate\n    float v;  // V coordinate\n};\n```\n\n## Implementation Guidelines\n\n### C# Texture Layering\n\n```csharp\npublic class TextureLayerManager\n{\n    private enum BlendMode\n    {\n        Opaque = 4,\n        Alpha = 0,\n        Add = 1,\n        Modulate = 2,\n        Modulate2X = 3\n    }\n    \n    private class MapChunkLayer\n    {\n        public uint TextureId { get; set; }\n        public uint AlphaMapId { get; set; }\n        public BlendMode BlendMode { get; set; }\n        public uint VertexShader { get; set; }\n        public uint PixelShader { get; set; }\n        public TexCoord0 TexCoord0 { get; set; }\n        public TexCoord1 TexCoord1 { get; set; }\n    }\n    \n    public void RenderChunkLayers(TerrainChunk chunk)\n    {\n        // Get number of layers\n        int numLayers = chunk.NumLayers;\n        \n        // Render each layer\n        for (int i = 0; i < numLayers; i++)\n        {\n            // Get layer\n            MapChunkLayer layer = chunk.Layers[i];\n            \n            // Set up texture\n            GL.ActiveTexture(TextureUnit.Texture0);\n            GL.BindTexture(TextureTarget.Texture2D, layer.TextureId);\n            \n            // Set up alpha map\n            GL.ActiveTexture(TextureUnit.Texture1);\n            GL.BindTexture(TextureTarget.Texture2D, layer.AlphaMapId);\n            \n            // Set up blend mode\n            SetBlendMode(layer.BlendMode);\n            \n            // Render layer\n            RenderLayer(chunk, layer);\n            \n            // Push render state for subsequent layers\n            if (i > 0)\n            {\n                PushRenderState();\n            }\n        }\n        \n        // Pop render states for all but first layer\n        for (int i = 1; i < numLayers; i++)\n        {\n            PopRenderState();\n        }\n    }\n    \n    private void RenderLayer(TerrainChunk chunk, MapChunkLayer layer)\n    {\n        // Set up vertex shader\n        GL.UseProgram(layer.VertexShader);\n        \n        // Set up pixel shader\n        GL.UseProgram(layer.PixelShader);\n        \n        // Set up texture coordinates\n        GL.Uniform2(texCoord0Location, layer.TexCoord0.U, layer.TexCoord0.V);\n        GL.Uniform2(texCoord1Location, layer.TexCoord1.U, layer.TexCoord1.V);\n        \n        // Draw triangles\n        GL.BindBuffer(BufferTarget.ArrayBuffer, chunk.VertexBuffer);\n        GL.BindBuffer(BufferTarget.ElementArrayBuffer, chunk.IndexBuffer);\n        GL.DrawElements(PrimitiveType.Triangles, chunk.IndexCount, DrawElementsType.UnsignedInt, 0);\n    }\n    \n    private void SetBlendMode(BlendMode blendMode)\n    {\n        switch (blendMode)\n        {\n            case BlendMode.Opaque:\n                GL.Disable(EnableCap.Blend);\n                break;\n            case BlendMode.Alpha:\n                GL.Enable(EnableCap.Blend);\n                GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.OneMinusSrcAlpha);\n                break;\n            case BlendMode.Add:\n                GL.Enable(EnableCap.Blend);\n                GL.BlendFunc(BlendingFactor.SrcAlpha, BlendingFactor.One);\n                break;\n            case BlendMode.Modulate:\n                GL.Enable(EnableCap.Blend);\n                GL.BlendFunc(BlendingFactor.DstColor, BlendingFactor.Zero);\n                break;\n            case BlendMode.Modulate2X:\n                GL.Enable(EnableCap.Blend);\n                GL.BlendFunc(BlendingFactor.DstColor, BlendingFactor.SrcColor);\n                break;\n        }\n    }\n    \n    private void PushRenderState()\n    {\n        // Push render state\n        GL.PushAttrib(AttribMask.AllAttribBits);\n    }\n    \n    private void PopRenderState()\n    {\n        // Pop render state\n        GL.PopAttrib();\n    }\n}\n```\n\n## References\n\n- [`CMapChunk::Render`](0x006a6d80) (0x006a6d80) - Render chunk with texture layering\n- [`CMapChunk::RenderLayer`](0x006a6e00) (0x006a6e00) - Render single layer\n- [`CMapChunk::SetBlendMode`](0x006a6e50) (0x006a6e50) - Set blend mode\n- [`CMapChunk::SampleAlphaMap`](0x006a6ea0) (0x006a6ea0) - Sample alpha map"}]