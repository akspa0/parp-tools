using System;
using System.Collections.Generic;
using System.IO;
using GillijimProject.WowFiles; // for Chunk
using GillijimProject.WowFiles.LichKing;
using U = GillijimProject.Utilities.Utilities;

namespace GillijimProject.WowFiles.Alpha;

/// <summary>
/// [PORT] Minimal C# port of AdtAlpha (see lib/gillijimproject/wowfiles/alpha/AdtAlpha.{h,cpp})
/// This establishes constructor parity and basic helpers (coords), leaving full parsing for later.
/// </summary>
public class AdtAlpha : WowFiles.WowChunkedFormat
{
    private readonly int _adtNumber;
    private readonly string _adtFileName;
    private readonly string _wdtAlphaPath;
    private readonly int _x;
    private readonly int _y;
    private readonly Chunk _mhdr;
    private readonly Mcin _mcin;
    private readonly Chunk _mtex;
    private readonly Mddf _mddf;
    private readonly Modf _modf;

    /// <summary>
    /// [PORT] Constructor parity (wdtAlphaName, offsetInFile, adtNum).
    /// Offset not used yet; full parsing is deferred until dependent classes are ported.
    /// </summary>
    public AdtAlpha(string wdtAlphaName, int offsetInFile, int adtNum)
    {
        _adtNumber = adtNum;
        _x = adtNum % 64;
        _y = adtNum / 64;
        _adtFileName = GetAdtFileName(wdtAlphaName, _x, _y);
        _wdtAlphaPath = wdtAlphaName;

        using var wdtAlphaFile = File.OpenRead(wdtAlphaName);

        const int mcinOffset = 0x0;
        const int mtexOffset = 0x4;
        const int mddfOffset = 0x0C;
        const int modfOffset = 0x14;

        _mhdr = new Chunk(wdtAlphaFile, offsetInFile);
        int mhdrStartOffset = offsetInFile + ChunkLettersAndSize;

        int off = mhdrStartOffset + _mhdr.GetOffset(mcinOffset);
        _mcin = new Mcin(wdtAlphaFile, off);

        off = mhdrStartOffset + _mhdr.GetOffset(mtexOffset);
        _mtex = new Chunk(wdtAlphaFile, off);

        off = mhdrStartOffset + _mhdr.GetOffset(mddfOffset);
        _mddf = new Mddf(wdtAlphaFile, off);

        off = mhdrStartOffset + _mhdr.GetOffset(modfOffset);
        _modf = new Modf(wdtAlphaFile, off);
    }

    /// <summary>
    /// [PORT] X tile coordinate in the 64x64 grid.
    /// </summary>
    public int GetXCoord() => _x;

    /// <summary>
    /// [PORT] Y tile coordinate in the 64x64 grid.
    /// </summary>
    public int GetYCoord() => _y;

    /// <summary>
    /// [PORT] Convert to LichKing ADT placeholder until full conversion is ported.
    /// Produces a minimal ADT with MVER (0x12) and MHDR (64 bytes zeroed).
    /// </summary>
    public AdtLk ToAdtLk(List<string> mdnmFileNames, List<string> monmFileNames)
    {
        // MVER for LK (0x12)
        var mverData = new byte[] { 0x12, 0x00, 0x00, 0x00 };
        var cMver = new Chunk("MVER", mverData.Length, mverData);

        // [PORT] MHDR will be generated by AdtLk based on provided components
        var cMh2o = new Mh2o("MH2O", 0, Array.Empty<byte>());

        // Build LK index chunks from alpha MDDF/MODF and WDT name tables
        var alphaM2Indices = _mddf.GetM2IndicesForMmdx();
        var cMmdx = new Mmdx(alphaM2Indices, mdnmFileNames);
        var cMmid = new Mmid(cMmdx.GetIndicesForMmid());

        var alphaWmoIndices = _modf.GetWmoIndicesForMwmo();
        var cMwmo = new Mwmo(alphaWmoIndices, monmFileNames);
        var cMwid = new Mwid(cMwmo.GetIndicesForMwid());

        // Copy and remap MDDF/MODF indices for LK
        // Copy and remap MDDF/MODF indices for LK
        // [PORT] Reference C++ implementation does NOT swap Y/Z. 
        // Assuming Alpha coordinates are already compatible (Z-up) or consistent with what's expected.
        var cMddf = new Mddf("MDDF", _mddf.Data.Length, (byte[])_mddf.Data.Clone());
        cMddf.UpdateIndicesForLk(alphaM2Indices);

        var cModf = new Modf("MODF", _modf.Data.Length, (byte[])_modf.Data.Clone());
        cModf.UpdateIndicesForLk(alphaWmoIndices);

        // Convert all present Alpha MCNKs into LK MCNKs using MCIN offsets
        var mcnkLkList = new List<McnkLk>(capacity: 256);
        var offsets = _mcin.GetMcnkOffsets();
        using (var fs = File.OpenRead(_wdtAlphaPath))
        {
            for (int i = 0; i < 256; i++)
            {
                int off = (i < offsets.Count) ? offsets[i] : 0;
                if (off > 0)
                {
                    var a = new McnkAlpha(fs, off, headerSize: 0, adtNum: _adtNumber);
                    var lk = a.ToMcnkLk(alphaM2Indices, alphaWmoIndices);
                    mcnkLkList.Add(lk);
                }
                else
                {
                    // Emit empty MCNK placeholder to preserve 256 entries
                    mcnkLkList.Add(new McnkLk());
                }
            }
        }

        return new AdtLk(
            _adtFileName,
            cMver,
            0,            // mhdrFlags
            cMh2o,
            _mtex,
            cMmdx,
            cMmid,
            cMwmo,
            cMwid,
            cMddf,
            cModf,
            mcnkLkList,
            new Chunk(),
            new Chunk());
    }

    /// <summary>
    /// Returns a list of 256 Alpha area IDs (or -1 when the MCNK is not present),
    /// inferred from McnkAlpha headers (Unknown3 field used by the original port as area candidate).
    /// </summary>
    public List<int> GetAlphaMcnkAreaIds()
    {
        var result = new List<int>(capacity: 256);
        for (int i = 0; i < 256; i++) result.Add(-1);

        var offsets = _mcin.GetMcnkOffsets();
        using var fs = File.OpenRead(_wdtAlphaPath);
        for (int i = 0; i < 256; i++)
        {
            int off = (i < offsets.Count) ? offsets[i] : 0;
            if (off > 0)
            {
                var a = new McnkAlpha(fs, off, headerSize: 0, adtNum: _adtNumber);
                result[i] = a.GetAlphaAreaId();
            }
        }
        return result;
    }

    /// <summary>
    /// Returns the 256 MCNK offsets from the MCIN chunk.
    /// </summary>
    public List<int> GetMcnkOffsets() => _mcin.GetMcnkOffsets();

    /// <summary>
    /// Exposes the set of Alpha MDDF indices referencing WDT MDNM names.
    /// Use WDT MDNM file list to resolve indices to model paths.
    /// </summary>
    public List<int> GetAlphaM2Indices() => _mddf.GetM2IndicesForMmdx();

    /// <summary>
    /// Exposes the set of Alpha MODF indices referencing WDT MONM names.
    /// Use WDT MONM file list to resolve indices to WMO paths.
    /// </summary>
    public List<int> GetAlphaWmoIndices() => _modf.GetWmoIndicesForMwmo();

    /// <summary>
    /// Parses the MTEX chunk as a C-style string table and returns texture names.
    /// </summary>
    public List<string> GetMtexTextureNames()
    {
        var result = new List<string>();
        if (_mtex is null || _mtex.Data.Length == 0) return result;
        int start = 0;
        while (start < _mtex.Data.Length)
        {
            int end = Array.IndexOf<byte>(_mtex.Data, 0, start);
            if (end < 0) end = _mtex.Data.Length;
            int len = end - start;
            if (len > 0)
            {
                var s = System.Text.Encoding.ASCII.GetString(_mtex.Data, start, len);
                if (!string.IsNullOrWhiteSpace(s)) result.Add(s);
            }
            start = end + 1;
        }
        return result;
    }

    /// <summary>
    /// Returns a copy of the raw MDDF bytes for external analysis (entry size 36 bytes in Alpha).
    /// </summary>
    public byte[] GetMddfRaw()
    {
        return _mddf?.Data is null ? Array.Empty<byte>() : (byte[])_mddf.Data.Clone();
    }

    /// <summary>
    /// Returns a copy of the raw MODF bytes for external analysis (entry size 64 bytes in Alpha).
    /// </summary>
    public byte[] GetModfRaw()
    {
        return _modf?.Data is null ? Array.Empty<byte>() : (byte[])_modf.Data.Clone();
    }

    private static string GetAdtFileName(string wdtName, int x, int y)
    {
        // [PORT] Basename only; writers choose output directory.
        var baseName = Path.GetFileNameWithoutExtension(wdtName);
        return $"{baseName}_{x}_{y}.adt";
    }

}
